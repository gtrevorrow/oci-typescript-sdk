/**
 * Generative AI Agents Management API
 * OCI Generative AI Agents is a fully managed service that combines the power of large language models (LLMs) with an intelligent retrieval system to create contextually relevant answers by searching your knowledge base, making your AI applications smart and efficient.

OCI Generative AI Agents supports several ways to onboard your data and then allows you and your customers to interact with your data using a chat interface or API.

Use the Generative AI Agents API to create and manage agents, knowledge bases, data sources, endpoints, data ingestion jobs, and work requests.

For creating and managing client chat sessions see the {@link #eNGenerative-ai-agents-clientLatest(ENGenerative-ai-agents-clientLatestRequest) eNGenerative-ai-agents-clientLatest}.

To learn more about the service, see the [Generative AI Agents documentation](https://docs.oracle.com/iaas/Content/generative-ai-agents/home.htm).

 * OpenAPI spec version: 20240531
 * 
 *
 * NOTE: This class is auto generated by OracleSDKGenerator.
 * Do not edit the class manually.
 *
 * Copyright (c) 2020, 2025, Oracle and/or its affiliates.  All rights reserved.
 * This software is dual-licensed to you under the Universal Permissive License (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl or Apache License 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose either license.
 */

import * as serviceRequests from "./request";
import * as serviceResponses from "./response";
import * as models from "./model";
import { GenerativeAiAgentClient } from "./client";
import { genericWaiter, genericTerminalConditionWaiter, WaiterConfiguration } from "oci-common";

export class GenerativeAiAgentWaiter {
  public constructor(
    private client: GenerativeAiAgentClient,
    private readonly config?: WaiterConfiguration
  ) {}

  /**
   * Waits forAgent till it reaches any of the provided states
   *
   * @param request the request to send
   * @param targetStates the desired states to wait for. The waiter will return once the resource reaches any of the provided states
   * @return response returns GetAgentResponse | null (null in case of 404 response)
   */
  public async forAgent(
    request: serviceRequests.GetAgentRequest,
    ...targetStates: models.Agent.LifecycleState[]
  ): Promise<serviceResponses.GetAgentResponse | null> {
    return genericTerminalConditionWaiter(
      this.config,
      () => this.client.getAgent(request),
      response => targetStates.includes(response.agent.lifecycleState!),
      targetStates.includes(models.Agent.LifecycleState.Deleted)
    );
  }

  /**
   * Waits forAgentEndpoint till it reaches any of the provided states
   *
   * @param request the request to send
   * @param targetStates the desired states to wait for. The waiter will return once the resource reaches any of the provided states
   * @return response returns GetAgentEndpointResponse | null (null in case of 404 response)
   */
  public async forAgentEndpoint(
    request: serviceRequests.GetAgentEndpointRequest,
    ...targetStates: models.AgentEndpoint.LifecycleState[]
  ): Promise<serviceResponses.GetAgentEndpointResponse | null> {
    return genericTerminalConditionWaiter(
      this.config,
      () => this.client.getAgentEndpoint(request),
      response => targetStates.includes(response.agentEndpoint.lifecycleState!),
      targetStates.includes(models.AgentEndpoint.LifecycleState.Deleted)
    );
  }

  /**
   * Waits forDataIngestionJob till it reaches any of the provided states
   *
   * @param request the request to send
   * @param targetStates the desired states to wait for. The waiter will return once the resource reaches any of the provided states
   * @return response returns GetDataIngestionJobResponse | null (null in case of 404 response)
   */
  public async forDataIngestionJob(
    request: serviceRequests.GetDataIngestionJobRequest,
    ...targetStates: models.DataIngestionJob.LifecycleState[]
  ): Promise<serviceResponses.GetDataIngestionJobResponse | null> {
    return genericTerminalConditionWaiter(
      this.config,
      () => this.client.getDataIngestionJob(request),
      response => targetStates.includes(response.dataIngestionJob.lifecycleState!),
      targetStates.includes(models.DataIngestionJob.LifecycleState.Deleted)
    );
  }

  /**
   * Waits forDataSource till it reaches any of the provided states
   *
   * @param request the request to send
   * @param targetStates the desired states to wait for. The waiter will return once the resource reaches any of the provided states
   * @return response returns GetDataSourceResponse | null (null in case of 404 response)
   */
  public async forDataSource(
    request: serviceRequests.GetDataSourceRequest,
    ...targetStates: models.DataSource.LifecycleState[]
  ): Promise<serviceResponses.GetDataSourceResponse | null> {
    return genericTerminalConditionWaiter(
      this.config,
      () => this.client.getDataSource(request),
      response => targetStates.includes(response.dataSource.lifecycleState!),
      targetStates.includes(models.DataSource.LifecycleState.Deleted)
    );
  }

  /**
   * Waits forKnowledgeBase till it reaches any of the provided states
   *
   * @param request the request to send
   * @param targetStates the desired states to wait for. The waiter will return once the resource reaches any of the provided states
   * @return response returns GetKnowledgeBaseResponse | null (null in case of 404 response)
   */
  public async forKnowledgeBase(
    request: serviceRequests.GetKnowledgeBaseRequest,
    ...targetStates: models.KnowledgeBase.LifecycleState[]
  ): Promise<serviceResponses.GetKnowledgeBaseResponse | null> {
    return genericTerminalConditionWaiter(
      this.config,
      () => this.client.getKnowledgeBase(request),
      response => targetStates.includes(response.knowledgeBase.lifecycleState!),
      targetStates.includes(models.KnowledgeBase.LifecycleState.Deleted)
    );
  }

  /**
   * Waits forWorkRequest
   *
   * @param request the request to send
   * @return response returns GetWorkRequestResponse
   */
  public async forWorkRequest(
    request: serviceRequests.GetWorkRequestRequest
  ): Promise<serviceResponses.GetWorkRequestResponse> {
    return genericWaiter(
      this.config,
      () => this.client.getWorkRequest(request),
      response => (response.workRequest.timeFinished ? true : false)
    );
  }
}
