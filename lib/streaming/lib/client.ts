/**
 * Streaming API
 * Use the Streaming API to produce and consume messages, create streams and stream pools, and manage related items. For more information, see [Streaming](https://docs.oracle.com/iaas/Content/Streaming/Concepts/streamingoverview.htm).
 * OpenAPI spec version: 20180418
 *
 *
 * NOTE: This class is auto generated by OracleSDKGenerator.
 * Do not edit the class manually.
 *
 * Copyright (c) 2020, 2025, Oracle and/or its affiliates.  All rights reserved.
 * This software is dual-licensed to you under the Universal Permissive License (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl or Apache License 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose either license.
 */

import common = require("oci-common");
import * as requests from "./request";
import * as model from "./model";
import * as responses from "./response";
import { paginateRecords, paginateResponses } from "oci-common";
import { StreamAdminWaiter } from "./streamadmin-waiter";
import {
  composeResponse,
  composeRequest,
  GenericRetrier,
  developerToolConfiguration
} from "oci-common";
const Breaker = require("opossum");

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum StreamApiKeys {}
/**
 * This service client does not use circuit breakers by default if the user has not defined a circuit breaker configuration.
 */
export class StreamClient {
  protected static serviceEndpointTemplate = "https://streaming.{region}.oci.{secondLevelDomain}";
  protected static endpointServiceName = "";
  protected "_realmSpecificEndpointTemplateEnabled": boolean | undefined = undefined;
  protected "_endpoint": string = "";
  protected "_defaultHeaders": any = {};
  protected "_clientConfiguration": common.ClientConfiguration;
  protected _circuitBreaker: typeof Breaker | null = null;
  protected _httpOptions: any = undefined;
  protected _bodyDuplexMode: any = undefined;
  public targetService = "Stream";

  protected _httpClient: common.HttpClient;
  protected _authProvider: common.AuthenticationDetailsProvider | undefined;

  constructor(params: common.AuthParams, clientConfiguration?: common.ClientConfiguration) {
    const requestSigner = params.authenticationDetailsProvider
      ? new common.DefaultRequestSigner(params.authenticationDetailsProvider)
      : null;
    this._authProvider = params.authenticationDetailsProvider;
    if (clientConfiguration) {
      this._clientConfiguration = clientConfiguration;
      this._circuitBreaker = clientConfiguration.circuitBreaker
        ? clientConfiguration.circuitBreaker!.circuit
        : null;
      this._httpOptions = clientConfiguration.httpOptions
        ? clientConfiguration.httpOptions
        : undefined;
      this._bodyDuplexMode = clientConfiguration.bodyDuplexMode
        ? clientConfiguration.bodyDuplexMode
        : undefined;
    }

    if (!developerToolConfiguration.isServiceEnabled("streaming")) {
      let errmsg =
        "The developerToolConfiguration configuration disabled this service, this behavior is controlled by developerToolConfiguration.ociEnabledServiceSet variable. Please check if your local developer_tool_configuration file has configured the service you're targeting or contact the cloud provider on the availability of this service : ";
      throw errmsg.concat("streaming");
    }

    // if circuit breaker is not created, check if circuit breaker system is enabled to use default circuit breaker
    const specCircuitBreakerEnabled = false;
    if (
      !this._circuitBreaker &&
      common.utils.isCircuitBreakerSystemEnabled(clientConfiguration!) &&
      (specCircuitBreakerEnabled || common.CircuitBreaker.DefaultCircuitBreakerOverriden)
    ) {
      this._circuitBreaker = new common.CircuitBreaker().circuit;
    }
    this._httpClient =
      params.httpClient ||
      new common.FetchHttpClient(
        requestSigner,
        this._circuitBreaker,
        this._httpOptions,
        this._bodyDuplexMode
      );
  }

  /**
   * Get the endpoint that is being used to call (ex, https://www.example.com).
   */
  public get endpoint() {
    return this._endpoint;
  }

  /**
   * Sets the endpoint to call (ex, https://www.example.com).
   * @param endpoint The endpoint of the service.
   */
  public set endpoint(endpoint: string) {
    this._endpoint = endpoint;
    this._endpoint = this._endpoint + "/20180418";
    if (this.logger) this.logger.info(`StreamClient endpoint set to ${this._endpoint}`);
  }

  public get logger() {
    return common.LOG.logger;
  }

  /**
   * Determines whether realm specific endpoint should be used or not.
   * Set realmSpecificEndpointTemplateEnabled to "true" if the user wants to enable use of realm specific endpoint template, otherwise set it to "false"
   * @param realmSpecificEndpointTemplateEnabled flag to enable the use of realm specific endpoint template
   */
  public set useRealmSpecificEndpointTemplate(realmSpecificEndpointTemplateEnabled: boolean) {
    this._realmSpecificEndpointTemplateEnabled = realmSpecificEndpointTemplateEnabled;
    if (this.logger)
      this.logger.info(
        `realmSpecificEndpointTemplateEnabled set to ${this._realmSpecificEndpointTemplateEnabled}`
      );
  }

  /**
   * Shutdown the circuit breaker used by the client when it is no longer needed
   */
  public shutdownCircuitBreaker() {
    if (this._circuitBreaker) {
      this._circuitBreaker.shutdown();
    }
  }

  /**
   * Close the provider if possible which in turn shuts down any associated circuit breaker
   */
  public closeProvider() {
    if (this._authProvider) {
      if (this._authProvider instanceof common.AbstractRequestingAuthenticationDetailsProvider)
        (<common.AbstractRequestingAuthenticationDetailsProvider>(
          this._authProvider
        )).closeProvider();
    }
  }

  /**
   * Close the client once it is no longer needed
   */
  public close() {
    this.shutdownCircuitBreaker();
    this.closeProvider();
  }

  /**
   * Provides a mechanism to manually commit offsets, if not using commit-on-get consumer semantics.
   * This commits offsets assicated with the provided cursor, extends the timeout on each of the affected partitions, and returns an updated cursor.
   *
   * This operation uses {@link common.OciSdkDefaultRetryConfiguration} by default if no retry configuration is defined by the user.
   * @param ConsumerCommitRequest
   * @return ConsumerCommitResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/streaming/ConsumerCommit.ts.html |here} to see how to use ConsumerCommit API.
   */
  public async consumerCommit(
    consumerCommitRequest: requests.ConsumerCommitRequest
  ): Promise<responses.ConsumerCommitResponse> {
    if (this.logger) this.logger.debug("Calling operation StreamClient#consumerCommit.");
    const operationName = "consumerCommit";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/streaming/20180418/Group/ConsumerCommit";
    const pathParams = {
      "{streamId}": consumerCommitRequest.streamId
    };

    const queryParams = {
      "cursor": consumerCommitRequest.cursor
    };

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": consumerCommitRequest.opcRequestId
    };

    const specRetryConfiguration = common.OciSdkDefaultRetryConfiguration;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      consumerCommitRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/streams/{streamId}/commit",
      method: "POST",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.ConsumerCommitResponse>{},
        body: await response.json(),
        bodyKey: "cursor",
        bodyModel: model.Cursor,
        type: "model.Cursor",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Allows long-running processes to extend the timeout on partitions reserved by a consumer instance.
   *
   * This operation uses {@link common.OciSdkDefaultRetryConfiguration} by default if no retry configuration is defined by the user.
   * @param ConsumerHeartbeatRequest
   * @return ConsumerHeartbeatResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/streaming/ConsumerHeartbeat.ts.html |here} to see how to use ConsumerHeartbeat API.
   */
  public async consumerHeartbeat(
    consumerHeartbeatRequest: requests.ConsumerHeartbeatRequest
  ): Promise<responses.ConsumerHeartbeatResponse> {
    if (this.logger) this.logger.debug("Calling operation StreamClient#consumerHeartbeat.");
    const operationName = "consumerHeartbeat";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/streaming/20180418/Group/ConsumerHeartbeat";
    const pathParams = {
      "{streamId}": consumerHeartbeatRequest.streamId
    };

    const queryParams = {
      "cursor": consumerHeartbeatRequest.cursor
    };

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": consumerHeartbeatRequest.opcRequestId
    };

    const specRetryConfiguration = common.OciSdkDefaultRetryConfiguration;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      consumerHeartbeatRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/streams/{streamId}/heartbeat",
      method: "POST",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.ConsumerHeartbeatResponse>{},
        body: await response.json(),
        bodyKey: "cursor",
        bodyModel: model.Cursor,
        type: "model.Cursor",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Creates a cursor. Cursors are used to consume a stream, starting from a specific point in the partition and going forward from there.
   * You can create a cursor based on an offset, a time, the trim horizon, or the most recent message in the stream. As the oldest message
   * inside the retention period boundary, using the trim horizon effectively lets you consume all messages in the stream. A cursor based
   * on the most recent message allows consumption of only messages that are added to the stream after you create the cursor. Cursors expire
   * five minutes after you receive them from the service.
   *
   * This operation uses {@link common.OciSdkDefaultRetryConfiguration} by default if no retry configuration is defined by the user.
   * @param CreateCursorRequest
   * @return CreateCursorResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/streaming/CreateCursor.ts.html |here} to see how to use CreateCursor API.
   */
  public async createCursor(
    createCursorRequest: requests.CreateCursorRequest
  ): Promise<responses.CreateCursorResponse> {
    if (this.logger) this.logger.debug("Calling operation StreamClient#createCursor.");
    const operationName = "createCursor";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/streaming/20180418/Cursor/CreateCursor";
    const pathParams = {
      "{streamId}": createCursorRequest.streamId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": createCursorRequest.opcRequestId
    };

    const specRetryConfiguration = common.OciSdkDefaultRetryConfiguration;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      createCursorRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/streams/{streamId}/cursors",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createCursorRequest.createCursorDetails,
        "CreateCursorDetails",
        model.CreateCursorDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateCursorResponse>{},
        body: await response.json(),
        bodyKey: "cursor",
        bodyModel: model.Cursor,
        type: "model.Cursor",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Creates a group-cursor.
   *
   * This operation uses {@link common.OciSdkDefaultRetryConfiguration} by default if no retry configuration is defined by the user.
   * @param CreateGroupCursorRequest
   * @return CreateGroupCursorResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/streaming/CreateGroupCursor.ts.html |here} to see how to use CreateGroupCursor API.
   */
  public async createGroupCursor(
    createGroupCursorRequest: requests.CreateGroupCursorRequest
  ): Promise<responses.CreateGroupCursorResponse> {
    if (this.logger) this.logger.debug("Calling operation StreamClient#createGroupCursor.");
    const operationName = "createGroupCursor";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/streaming/20180418/Cursor/CreateGroupCursor";
    const pathParams = {
      "{streamId}": createGroupCursorRequest.streamId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": createGroupCursorRequest.opcRequestId
    };

    const specRetryConfiguration = common.OciSdkDefaultRetryConfiguration;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      createGroupCursorRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/streams/{streamId}/groupCursors",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createGroupCursorRequest.createGroupCursorDetails,
        "CreateGroupCursorDetails",
        model.CreateGroupCursorDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateGroupCursorResponse>{},
        body: await response.json(),
        bodyKey: "cursor",
        bodyModel: model.Cursor,
        type: "model.Cursor",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Returns the current state of a consumer group.
   *
   * This operation uses {@link common.OciSdkDefaultRetryConfiguration} by default if no retry configuration is defined by the user.
   * @param GetGroupRequest
   * @return GetGroupResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/streaming/GetGroup.ts.html |here} to see how to use GetGroup API.
   */
  public async getGroup(
    getGroupRequest: requests.GetGroupRequest
  ): Promise<responses.GetGroupResponse> {
    if (this.logger) this.logger.debug("Calling operation StreamClient#getGroup.");
    const operationName = "getGroup";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/streaming/20180418/Group/GetGroup";
    const pathParams = {
      "{streamId}": getGroupRequest.streamId,
      "{groupName}": getGroupRequest.groupName
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": getGroupRequest.opcRequestId
    };

    const specRetryConfiguration = common.OciSdkDefaultRetryConfiguration;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      getGroupRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/streams/{streamId}/groups/{groupName}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.GetGroupResponse>{},
        body: await response.json(),
        bodyKey: "group",
        bodyModel: model.Group,
        type: "model.Group",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Returns messages from the specified stream using the specified cursor as the starting point for consumption. By default, the number of messages returned is undefined, but the service returns as many as possible.
   * To get messages, you must first obtain a cursor using the {@link #createCursor(CreateCursorRequest) createCursor} operation.
   * In the response, retrieve the value of the 'opc-next-cursor' header to pass as a parameter to get the next batch of messages in the stream.
   *
   * This operation uses {@link common.OciSdkDefaultRetryConfiguration} by default if no retry configuration is defined by the user.
   * @param GetMessagesRequest
   * @return GetMessagesResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/streaming/GetMessages.ts.html |here} to see how to use GetMessages API.
   */
  public async getMessages(
    getMessagesRequest: requests.GetMessagesRequest
  ): Promise<responses.GetMessagesResponse> {
    if (this.logger) this.logger.debug("Calling operation StreamClient#getMessages.");
    const operationName = "getMessages";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/streaming/20180418/Message/GetMessages";
    const pathParams = {
      "{streamId}": getMessagesRequest.streamId
    };

    const queryParams = {
      "cursor": getMessagesRequest.cursor,
      "limit": getMessagesRequest.limit
    };

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": getMessagesRequest.opcRequestId
    };

    const specRetryConfiguration = common.OciSdkDefaultRetryConfiguration;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      getMessagesRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/streams/{streamId}/messages",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.GetMessagesResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: model.Message,
        type: "Array<model.Message>",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-cursor"),
            key: "opcNextCursor",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Emits messages to a stream. There's no limit to the number of messages in a request, but the total size of a message or request must be 1 MiB or less.
   * The service calculates the partition ID from the message key and stores messages that share a key on the same partition.
   * If a message does not contain a key or if the key is null, the service generates a message key for you.
   * The partition ID cannot be passed as a parameter.
   *
   * This operation does not retry by default if the user has not defined a retry configuration.
   * @param PutMessagesRequest
   * @return PutMessagesResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/streaming/PutMessages.ts.html |here} to see how to use PutMessages API.
   */
  public async putMessages(
    putMessagesRequest: requests.PutMessagesRequest
  ): Promise<responses.PutMessagesResponse> {
    if (this.logger) this.logger.debug("Calling operation StreamClient#putMessages.");
    const operationName = "putMessages";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/streaming/20180418/Message/PutMessages";
    const pathParams = {
      "{streamId}": putMessagesRequest.streamId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": putMessagesRequest.opcRequestId
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      putMessagesRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/streams/{streamId}/messages",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        putMessagesRequest.putMessagesDetails,
        "PutMessagesDetails",
        model.PutMessagesDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink,
        true
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.PutMessagesResponse>{},
        body: await response.json(),
        bodyKey: "putMessagesResult",
        bodyModel: model.PutMessagesResult,
        type: "model.PutMessagesResult",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Forcefully changes the current location of a group as a whole; reseting processing location of all consumers to a particular location in the stream.
   *
   * This operation uses {@link common.OciSdkDefaultRetryConfiguration} by default if no retry configuration is defined by the user.
   * @param UpdateGroupRequest
   * @return UpdateGroupResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/streaming/UpdateGroup.ts.html |here} to see how to use UpdateGroup API.
   */
  public async updateGroup(
    updateGroupRequest: requests.UpdateGroupRequest
  ): Promise<responses.UpdateGroupResponse> {
    if (this.logger) this.logger.debug("Calling operation StreamClient#updateGroup.");
    const operationName = "updateGroup";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/streaming/20180418/Group/UpdateGroup";
    const pathParams = {
      "{streamId}": updateGroupRequest.streamId,
      "{groupName}": updateGroupRequest.groupName
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": updateGroupRequest.opcRequestId
    };

    const specRetryConfiguration = common.OciSdkDefaultRetryConfiguration;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      updateGroupRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/streams/{streamId}/groups/{groupName}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateGroupRequest.updateGroupDetails,
        "UpdateGroupDetails",
        model.UpdateGroupDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateGroupResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }
}
export enum StreamAdminApiKeys {}
/**
 * This service client uses {@link common.CircuitBreaker.DefaultConfiguration} for all the operations by default if no circuit breaker configuration is defined by the user.
 */
export class StreamAdminClient {
  protected static serviceEndpointTemplate = "https://streaming.{region}.oci.{secondLevelDomain}";
  protected static endpointServiceName = "";
  protected "_realmSpecificEndpointTemplateEnabled": boolean | undefined = undefined;
  protected "_endpoint": string = "";
  protected "_defaultHeaders": any = {};
  protected "_waiters": StreamAdminWaiter;
  protected "_clientConfiguration": common.ClientConfiguration;
  protected _circuitBreaker: typeof Breaker | null = null;
  protected _httpOptions: any = undefined;
  protected _bodyDuplexMode: any = undefined;
  public targetService = "StreamAdmin";
  protected _regionId: string = "";
  protected "_region": common.Region;
  protected _lastSetRegionOrRegionId: string = "";

  protected _httpClient: common.HttpClient;
  protected _authProvider: common.AuthenticationDetailsProvider | undefined;

  constructor(params: common.AuthParams, clientConfiguration?: common.ClientConfiguration) {
    const requestSigner = params.authenticationDetailsProvider
      ? new common.DefaultRequestSigner(params.authenticationDetailsProvider)
      : null;
    this._authProvider = params.authenticationDetailsProvider;
    if (clientConfiguration) {
      this._clientConfiguration = clientConfiguration;
      this._circuitBreaker = clientConfiguration.circuitBreaker
        ? clientConfiguration.circuitBreaker!.circuit
        : null;
      this._httpOptions = clientConfiguration.httpOptions
        ? clientConfiguration.httpOptions
        : undefined;
      this._bodyDuplexMode = clientConfiguration.bodyDuplexMode
        ? clientConfiguration.bodyDuplexMode
        : undefined;
    }

    if (!developerToolConfiguration.isServiceEnabled("streaming")) {
      let errmsg =
        "The developerToolConfiguration configuration disabled this service, this behavior is controlled by developerToolConfiguration.ociEnabledServiceSet variable. Please check if your local developer_tool_configuration file has configured the service you're targeting or contact the cloud provider on the availability of this service : ";
      throw errmsg.concat("streaming");
    }

    // if circuit breaker is not created, check if circuit breaker system is enabled to use default circuit breaker
    const specCircuitBreakerEnabled = true;
    if (
      !this._circuitBreaker &&
      common.utils.isCircuitBreakerSystemEnabled(clientConfiguration!) &&
      (specCircuitBreakerEnabled || common.CircuitBreaker.DefaultCircuitBreakerOverriden)
    ) {
      this._circuitBreaker = new common.CircuitBreaker().circuit;
    }
    this._httpClient =
      params.httpClient ||
      new common.FetchHttpClient(
        requestSigner,
        this._circuitBreaker,
        this._httpOptions,
        this._bodyDuplexMode
      );

    if (
      params.authenticationDetailsProvider &&
      common.isRegionProvider(params.authenticationDetailsProvider)
    ) {
      const provider: common.RegionProvider = params.authenticationDetailsProvider;
      if (provider.getRegion()) {
        this.region = provider.getRegion();
      }
    }
  }

  /**
   * Get the endpoint that is being used to call (ex, https://www.example.com).
   */
  public get endpoint() {
    return this._endpoint;
  }

  /**
   * Sets the endpoint to call (ex, https://www.example.com).
   * @param endpoint The endpoint of the service.
   */
  public set endpoint(endpoint: string) {
    this._endpoint = endpoint;
    this._endpoint = this._endpoint + "/20180418";
    if (this.logger) this.logger.info(`StreamAdminClient endpoint set to ${this._endpoint}`);
  }

  public get logger() {
    return common.LOG.logger;
  }

  /**
   * Determines whether realm specific endpoint should be used or not.
   * Set realmSpecificEndpointTemplateEnabled to "true" if the user wants to enable use of realm specific endpoint template, otherwise set it to "false"
   * @param realmSpecificEndpointTemplateEnabled flag to enable the use of realm specific endpoint template
   */
  public set useRealmSpecificEndpointTemplate(realmSpecificEndpointTemplateEnabled: boolean) {
    this._realmSpecificEndpointTemplateEnabled = realmSpecificEndpointTemplateEnabled;
    if (this.logger)
      this.logger.info(
        `realmSpecificEndpointTemplateEnabled set to ${this._realmSpecificEndpointTemplateEnabled}`
      );
    if (this._lastSetRegionOrRegionId === common.Region.REGION_STRING) {
      this.endpoint = common.EndpointBuilder.createEndpointFromRegion(
        StreamAdminClient.serviceEndpointTemplate,
        this._region,
        StreamAdminClient.endpointServiceName
      );
    } else if (this._lastSetRegionOrRegionId === common.Region.REGION_ID_STRING) {
      this.endpoint = common.EndpointBuilder.createEndpointFromRegionId(
        StreamAdminClient.serviceEndpointTemplate,
        this._regionId,
        StreamAdminClient.endpointServiceName
      );
    }
  }

  /**
   * Sets the region to call (ex, Region.US_PHOENIX_1).
   * Note, this will call {@link #endpoint(String) endpoint} after resolving the endpoint.
   * @param region The region of the service.
   */
  public set region(region: common.Region) {
    this._region = region;
    this.endpoint = common.EndpointBuilder.createEndpointFromRegion(
      StreamAdminClient.serviceEndpointTemplate,
      region,
      StreamAdminClient.endpointServiceName
    );
    this._lastSetRegionOrRegionId = common.Region.REGION_STRING;
  }

  /**
   * Sets the regionId to call (ex, 'us-phoenix-1').
   *
   * Note, this will first try to map the region ID to a known Region and call {@link #region(Region) region}.
   * If no known Region could be determined, it will create an endpoint assuming its in default Realm OC1
   * and then call {@link #endpoint(String) endpoint}.
   * @param regionId The public region ID.
   */
  public set regionId(regionId: string) {
    this._regionId = regionId;
    this.endpoint = common.EndpointBuilder.createEndpointFromRegionId(
      StreamAdminClient.serviceEndpointTemplate,
      regionId,
      StreamAdminClient.endpointServiceName
    );
    this._lastSetRegionOrRegionId = common.Region.REGION_ID_STRING;
  }

  /**
   * Creates a new StreamAdminWaiter for resources for this service.
   *
   * @param config The waiter configuration for termination and delay strategy
   * @return The service waiters.
   */
  public createWaiters(config?: common.WaiterConfiguration): StreamAdminWaiter {
    this._waiters = new StreamAdminWaiter(this, config);
    return this._waiters;
  }

  /**
   * Gets the waiters available for resources for this service.
   *
   * @return The service waiters.
   */
  public getWaiters(): StreamAdminWaiter {
    if (this._waiters) {
      return this._waiters;
    }
    throw Error("Waiters do not exist. Please create waiters.");
  }

  /**
   * Shutdown the circuit breaker used by the client when it is no longer needed
   */
  public shutdownCircuitBreaker() {
    if (this._circuitBreaker) {
      this._circuitBreaker.shutdown();
    }
  }

  /**
   * Close the provider if possible which in turn shuts down any associated circuit breaker
   */
  public closeProvider() {
    if (this._authProvider) {
      if (this._authProvider instanceof common.AbstractRequestingAuthenticationDetailsProvider)
        (<common.AbstractRequestingAuthenticationDetailsProvider>(
          this._authProvider
        )).closeProvider();
    }
  }

  /**
   * Close the client once it is no longer needed
   */
  public close() {
    this.shutdownCircuitBreaker();
    this.closeProvider();
  }

  /**
   * Moves a resource into a different compartment. When provided, If-Match is checked against ETag values of the resource.
   * This operation uses {@link common.OciSdkDefaultRetryConfiguration} by default if no retry configuration is defined by the user.
   * @param ChangeConnectHarnessCompartmentRequest
   * @return ChangeConnectHarnessCompartmentResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/streaming/ChangeConnectHarnessCompartment.ts.html |here} to see how to use ChangeConnectHarnessCompartment API.
   */
  public async changeConnectHarnessCompartment(
    changeConnectHarnessCompartmentRequest: requests.ChangeConnectHarnessCompartmentRequest
  ): Promise<responses.ChangeConnectHarnessCompartmentResponse> {
    if (this.logger)
      this.logger.debug("Calling operation StreamAdminClient#changeConnectHarnessCompartment.");
    const operationName = "changeConnectHarnessCompartment";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/streaming/20180418/ConnectHarness/ChangeConnectHarnessCompartment";
    const pathParams = {
      "{connectHarnessId}": changeConnectHarnessCompartmentRequest.connectHarnessId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "if-match": changeConnectHarnessCompartmentRequest.ifMatch,
      "opc-request-id": changeConnectHarnessCompartmentRequest.opcRequestId
    };

    const specRetryConfiguration = common.OciSdkDefaultRetryConfiguration;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      changeConnectHarnessCompartmentRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/connectharnesses/{connectHarnessId}/actions/changeCompartment",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        changeConnectHarnessCompartmentRequest.changeConnectHarnessCompartmentDetails,
        "ChangeConnectHarnessCompartmentDetails",
        model.ChangeConnectHarnessCompartmentDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.ChangeConnectHarnessCompartmentResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Moves a resource into a different compartment.
   * When provided, If-Match is checked against ETag values of the resource.
   * The stream will also be moved into the default stream pool in the destination compartment.
   *
   * This operation uses {@link common.OciSdkDefaultRetryConfiguration} by default if no retry configuration is defined by the user.
   * @param ChangeStreamCompartmentRequest
   * @return ChangeStreamCompartmentResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/streaming/ChangeStreamCompartment.ts.html |here} to see how to use ChangeStreamCompartment API.
   */
  public async changeStreamCompartment(
    changeStreamCompartmentRequest: requests.ChangeStreamCompartmentRequest
  ): Promise<responses.ChangeStreamCompartmentResponse> {
    if (this.logger)
      this.logger.debug("Calling operation StreamAdminClient#changeStreamCompartment.");
    const operationName = "changeStreamCompartment";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/streaming/20180418/Stream/ChangeStreamCompartment";
    const pathParams = {
      "{streamId}": changeStreamCompartmentRequest.streamId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "if-match": changeStreamCompartmentRequest.ifMatch,
      "opc-request-id": changeStreamCompartmentRequest.opcRequestId
    };

    const specRetryConfiguration = common.OciSdkDefaultRetryConfiguration;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      changeStreamCompartmentRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/streams/{streamId}/actions/changeCompartment",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        changeStreamCompartmentRequest.changeStreamCompartmentDetails,
        "ChangeStreamCompartmentDetails",
        model.ChangeStreamCompartmentDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.ChangeStreamCompartmentResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Moves a resource into a different compartment. When provided, If-Match is checked against ETag values of the resource.
   * This operation uses {@link common.OciSdkDefaultRetryConfiguration} by default if no retry configuration is defined by the user.
   * @param ChangeStreamPoolCompartmentRequest
   * @return ChangeStreamPoolCompartmentResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/streaming/ChangeStreamPoolCompartment.ts.html |here} to see how to use ChangeStreamPoolCompartment API.
   */
  public async changeStreamPoolCompartment(
    changeStreamPoolCompartmentRequest: requests.ChangeStreamPoolCompartmentRequest
  ): Promise<responses.ChangeStreamPoolCompartmentResponse> {
    if (this.logger)
      this.logger.debug("Calling operation StreamAdminClient#changeStreamPoolCompartment.");
    const operationName = "changeStreamPoolCompartment";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/streaming/20180418/StreamPool/ChangeStreamPoolCompartment";
    const pathParams = {
      "{streamPoolId}": changeStreamPoolCompartmentRequest.streamPoolId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "if-match": changeStreamPoolCompartmentRequest.ifMatch,
      "opc-request-id": changeStreamPoolCompartmentRequest.opcRequestId
    };

    const specRetryConfiguration = common.OciSdkDefaultRetryConfiguration;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      changeStreamPoolCompartmentRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/streampools/{streamPoolId}/actions/changeCompartment",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        changeStreamPoolCompartmentRequest.changeStreamPoolCompartmentDetails,
        "ChangeStreamPoolCompartmentDetails",
        model.ChangeStreamPoolCompartmentDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.ChangeStreamPoolCompartmentResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Starts the provisioning of a new connect harness.
   * To track the progress of the provisioning, you can periodically call {@link ConnectHarness} object tells you its current state.
   *
   * This operation uses {@link common.OciSdkDefaultRetryConfiguration} by default if no retry configuration is defined by the user.
   * @param CreateConnectHarnessRequest
   * @return CreateConnectHarnessResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/streaming/CreateConnectHarness.ts.html |here} to see how to use CreateConnectHarness API.
   */
  public async createConnectHarness(
    createConnectHarnessRequest: requests.CreateConnectHarnessRequest
  ): Promise<responses.CreateConnectHarnessResponse> {
    if (this.logger) this.logger.debug("Calling operation StreamAdminClient#createConnectHarness.");
    const operationName = "createConnectHarness";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/streaming/20180418/ConnectHarness/CreateConnectHarness";
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": createConnectHarnessRequest.opcRequestId,
      "opc-retry-token": createConnectHarnessRequest.opcRetryToken
    };

    const specRetryConfiguration = common.OciSdkDefaultRetryConfiguration;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      createConnectHarnessRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/connectharnesses",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createConnectHarnessRequest.createConnectHarnessDetails,
        "CreateConnectHarnessDetails",
        model.CreateConnectHarnessDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateConnectHarnessResponse>{},
        body: await response.json(),
        bodyKey: "connectHarness",
        bodyModel: model.ConnectHarness,
        type: "model.ConnectHarness",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Starts the provisioning of a new stream.
   * The stream will be created in the given compartment id or stream pool id, depending on which parameter is specified.
   * Compartment id and stream pool id cannot be specified at the same time.
   * To track the progress of the provisioning, you can periodically call {@link #getStream(GetStreamRequest) getStream}.
   * In the response, the `lifecycleState` parameter of the {@link Stream} object tells you its current state.
   *
   * This operation uses {@link common.OciSdkDefaultRetryConfiguration} by default if no retry configuration is defined by the user.
   * @param CreateStreamRequest
   * @return CreateStreamResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/streaming/CreateStream.ts.html |here} to see how to use CreateStream API.
   */
  public async createStream(
    createStreamRequest: requests.CreateStreamRequest
  ): Promise<responses.CreateStreamResponse> {
    if (this.logger) this.logger.debug("Calling operation StreamAdminClient#createStream.");
    const operationName = "createStream";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/streaming/20180418/Stream/CreateStream";
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": createStreamRequest.opcRequestId
    };

    const specRetryConfiguration = common.OciSdkDefaultRetryConfiguration;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      createStreamRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/streams",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createStreamRequest.createStreamDetails,
        "CreateStreamDetails",
        model.CreateStreamDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateStreamResponse>{},
        body: await response.json(),
        bodyKey: "stream",
        bodyModel: model.Stream,
        type: "model.Stream",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Starts the provisioning of a new stream pool.
   * To track the progress of the provisioning, you can periodically call GetStreamPool.
   * In the response, the `lifecycleState` parameter of the object tells you its current state.
   *
   * This operation uses {@link common.OciSdkDefaultRetryConfiguration} by default if no retry configuration is defined by the user.
   * @param CreateStreamPoolRequest
   * @return CreateStreamPoolResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/streaming/CreateStreamPool.ts.html |here} to see how to use CreateStreamPool API.
   */
  public async createStreamPool(
    createStreamPoolRequest: requests.CreateStreamPoolRequest
  ): Promise<responses.CreateStreamPoolResponse> {
    if (this.logger) this.logger.debug("Calling operation StreamAdminClient#createStreamPool.");
    const operationName = "createStreamPool";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/streaming/20180418/StreamPool/CreateStreamPool";
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": createStreamPoolRequest.opcRequestId,
      "opc-retry-token": createStreamPoolRequest.opcRetryToken
    };

    const specRetryConfiguration = common.OciSdkDefaultRetryConfiguration;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      createStreamPoolRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/streampools",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createStreamPoolRequest.createStreamPoolDetails,
        "CreateStreamPoolDetails",
        model.CreateStreamPoolDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateStreamPoolResponse>{},
        body: await response.json(),
        bodyKey: "streamPool",
        bodyModel: model.StreamPool,
        type: "model.StreamPool",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Deletes a connect harness and its content. Connect harness contents are deleted immediately. The service retains records of the connect harness itself for 90 days after deletion.
   * The `lifecycleState` parameter of the `ConnectHarness` object changes to `DELETING` and the connect harness becomes inaccessible for read or write operations.
   * To verify that a connect harness has been deleted, make a {@link #getConnectHarness(GetConnectHarnessRequest) getConnectHarness} request. If the call returns the connect harness's
   * lifecycle state as `DELETED`, then the connect harness has been deleted. If the call returns a \"404 Not Found\" error, that means all records of the
   * connect harness have been deleted.
   *
   * This operation uses {@link common.OciSdkDefaultRetryConfiguration} by default if no retry configuration is defined by the user.
   * @param DeleteConnectHarnessRequest
   * @return DeleteConnectHarnessResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/streaming/DeleteConnectHarness.ts.html |here} to see how to use DeleteConnectHarness API.
   */
  public async deleteConnectHarness(
    deleteConnectHarnessRequest: requests.DeleteConnectHarnessRequest
  ): Promise<responses.DeleteConnectHarnessResponse> {
    if (this.logger) this.logger.debug("Calling operation StreamAdminClient#deleteConnectHarness.");
    const operationName = "deleteConnectHarness";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/streaming/20180418/ConnectHarness/DeleteConnectHarness";
    const pathParams = {
      "{connectHarnessId}": deleteConnectHarnessRequest.connectHarnessId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": deleteConnectHarnessRequest.opcRequestId,
      "if-match": deleteConnectHarnessRequest.ifMatch
    };

    const specRetryConfiguration = common.OciSdkDefaultRetryConfiguration;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      deleteConnectHarnessRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/connectharnesses/{connectHarnessId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteConnectHarnessResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Deletes a stream and its content. Stream contents are deleted immediately. The service retains records of the stream itself for 90 days after deletion.
   * The `lifecycleState` parameter of the `Stream` object changes to `DELETING` and the stream becomes inaccessible for read or write operations.
   * To verify that a stream has been deleted, make a {@link #getStream(GetStreamRequest) getStream} request. If the call returns the stream's
   * lifecycle state as `DELETED`, then the stream has been deleted. If the call returns a \"404 Not Found\" error, that means all records of the
   * stream have been deleted.
   *
   * This operation uses {@link common.OciSdkDefaultRetryConfiguration} by default if no retry configuration is defined by the user.
   * @param DeleteStreamRequest
   * @return DeleteStreamResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/streaming/DeleteStream.ts.html |here} to see how to use DeleteStream API.
   */
  public async deleteStream(
    deleteStreamRequest: requests.DeleteStreamRequest
  ): Promise<responses.DeleteStreamResponse> {
    if (this.logger) this.logger.debug("Calling operation StreamAdminClient#deleteStream.");
    const operationName = "deleteStream";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/streaming/20180418/Stream/DeleteStream";
    const pathParams = {
      "{streamId}": deleteStreamRequest.streamId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": deleteStreamRequest.opcRequestId,
      "if-match": deleteStreamRequest.ifMatch
    };

    const specRetryConfiguration = common.OciSdkDefaultRetryConfiguration;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      deleteStreamRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/streams/{streamId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteStreamResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Deletes a stream pool. All containing streams will also be deleted.
   * The default stream pool of a compartment cannot be deleted.
   *
   * This operation uses {@link common.OciSdkDefaultRetryConfiguration} by default if no retry configuration is defined by the user.
   * @param DeleteStreamPoolRequest
   * @return DeleteStreamPoolResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/streaming/DeleteStreamPool.ts.html |here} to see how to use DeleteStreamPool API.
   */
  public async deleteStreamPool(
    deleteStreamPoolRequest: requests.DeleteStreamPoolRequest
  ): Promise<responses.DeleteStreamPoolResponse> {
    if (this.logger) this.logger.debug("Calling operation StreamAdminClient#deleteStreamPool.");
    const operationName = "deleteStreamPool";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/streaming/20180418/StreamPool/DeleteStreamPool";
    const pathParams = {
      "{streamPoolId}": deleteStreamPoolRequest.streamPoolId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": deleteStreamPoolRequest.opcRequestId,
      "if-match": deleteStreamPoolRequest.ifMatch
    };

    const specRetryConfiguration = common.OciSdkDefaultRetryConfiguration;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      deleteStreamPoolRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/streampools/{streamPoolId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteStreamPoolResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Gets detailed information about a connect harness.
   * This operation uses {@link common.OciSdkDefaultRetryConfiguration} by default if no retry configuration is defined by the user.
   * @param GetConnectHarnessRequest
   * @return GetConnectHarnessResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/streaming/GetConnectHarness.ts.html |here} to see how to use GetConnectHarness API.
   */
  public async getConnectHarness(
    getConnectHarnessRequest: requests.GetConnectHarnessRequest
  ): Promise<responses.GetConnectHarnessResponse> {
    if (this.logger) this.logger.debug("Calling operation StreamAdminClient#getConnectHarness.");
    const operationName = "getConnectHarness";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/streaming/20180418/ConnectHarness/GetConnectHarness";
    const pathParams = {
      "{connectHarnessId}": getConnectHarnessRequest.connectHarnessId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": getConnectHarnessRequest.opcRequestId
    };

    const specRetryConfiguration = common.OciSdkDefaultRetryConfiguration;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      getConnectHarnessRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/connectharnesses/{connectHarnessId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.GetConnectHarnessResponse>{},
        body: await response.json(),
        bodyKey: "connectHarness",
        bodyModel: model.ConnectHarness,
        type: "model.ConnectHarness",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Gets detailed information about a stream, including the number of partitions.
   * This operation uses {@link common.OciSdkDefaultRetryConfiguration} by default if no retry configuration is defined by the user.
   * @param GetStreamRequest
   * @return GetStreamResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/streaming/GetStream.ts.html |here} to see how to use GetStream API.
   */
  public async getStream(
    getStreamRequest: requests.GetStreamRequest
  ): Promise<responses.GetStreamResponse> {
    if (this.logger) this.logger.debug("Calling operation StreamAdminClient#getStream.");
    const operationName = "getStream";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/streaming/20180418/Stream/GetStream";
    const pathParams = {
      "{streamId}": getStreamRequest.streamId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": getStreamRequest.opcRequestId
    };

    const specRetryConfiguration = common.OciSdkDefaultRetryConfiguration;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      getStreamRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/streams/{streamId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.GetStreamResponse>{},
        body: await response.json(),
        bodyKey: "stream",
        bodyModel: model.Stream,
        type: "model.Stream",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Gets detailed information about the stream pool, such as Kafka settings.
   * This operation uses {@link common.OciSdkDefaultRetryConfiguration} by default if no retry configuration is defined by the user.
   * @param GetStreamPoolRequest
   * @return GetStreamPoolResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/streaming/GetStreamPool.ts.html |here} to see how to use GetStreamPool API.
   */
  public async getStreamPool(
    getStreamPoolRequest: requests.GetStreamPoolRequest
  ): Promise<responses.GetStreamPoolResponse> {
    if (this.logger) this.logger.debug("Calling operation StreamAdminClient#getStreamPool.");
    const operationName = "getStreamPool";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/streaming/20180418/StreamPool/GetStreamPool";
    const pathParams = {
      "{streamPoolId}": getStreamPoolRequest.streamPoolId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": getStreamPoolRequest.opcRequestId
    };

    const specRetryConfiguration = common.OciSdkDefaultRetryConfiguration;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      getStreamPoolRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/streampools/{streamPoolId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.GetStreamPoolResponse>{},
        body: await response.json(),
        bodyKey: "streamPool",
        bodyModel: model.StreamPool,
        type: "model.StreamPool",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Lists the connectharness.
   * This operation uses {@link common.OciSdkDefaultRetryConfiguration} by default if no retry configuration is defined by the user.
   * @param ListConnectHarnessesRequest
   * @return ListConnectHarnessesResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/streaming/ListConnectHarnesses.ts.html |here} to see how to use ListConnectHarnesses API.
   */
  public async listConnectHarnesses(
    listConnectHarnessesRequest: requests.ListConnectHarnessesRequest
  ): Promise<responses.ListConnectHarnessesResponse> {
    if (this.logger) this.logger.debug("Calling operation StreamAdminClient#listConnectHarnesses.");
    const operationName = "listConnectHarnesses";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/streaming/20180418/ConnectHarnessSummary/ListConnectHarnesses";
    const pathParams = {};

    const queryParams = {
      "compartmentId": listConnectHarnessesRequest.compartmentId,
      "id": listConnectHarnessesRequest.id,
      "name": listConnectHarnessesRequest.name,
      "limit": listConnectHarnessesRequest.limit,
      "page": listConnectHarnessesRequest.page,
      "sortBy": listConnectHarnessesRequest.sortBy,
      "sortOrder": listConnectHarnessesRequest.sortOrder,
      "lifecycleState": listConnectHarnessesRequest.lifecycleState
    };

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": listConnectHarnessesRequest.opcRequestId
    };

    const specRetryConfiguration = common.OciSdkDefaultRetryConfiguration;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      listConnectHarnessesRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/connectharnesses",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.ListConnectHarnessesResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: model.ConnectHarnessSummary,
        type: "Array<model.ConnectHarnessSummary>",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-prev-page"),
            key: "opcPrevPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * NOTE: This function is deprecated in favor of listConnectHarnessesRecordIterator function.
   * Creates a new async iterator which will iterate over the models.ConnectHarnessSummary objects
   * contained in responses from the listConnectHarnesses operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllConnectHarnesses(
    request: requests.ListConnectHarnessesRequest
  ): AsyncIterableIterator<model.ConnectHarnessSummary> {
    return paginateRecords(request, req => this.listConnectHarnesses(req));
  }

  /**
   * NOTE: This function is deprecated in favor of listConnectHarnessesResponseIterator function.
   * Creates a new async iterator which will iterate over the responses received from the listConnectHarnesses operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllConnectHarnessesResponses(
    request: requests.ListConnectHarnessesRequest
  ): AsyncIterableIterator<responses.ListConnectHarnessesResponse> {
    return paginateResponses(request, req => this.listConnectHarnesses(req));
  }

  /**
   * Creates a new async iterator which will iterate over the models.ConnectHarnessSummary objects
   * contained in responses from the listConnectHarnesses operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listConnectHarnessesRecordIterator(
    request: requests.ListConnectHarnessesRequest
  ): AsyncIterableIterator<model.ConnectHarnessSummary> {
    return paginateRecords(request, req => this.listConnectHarnesses(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listConnectHarnesses operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listConnectHarnessesResponseIterator(
    request: requests.ListConnectHarnessesRequest
  ): AsyncIterableIterator<responses.ListConnectHarnessesResponse> {
    return paginateResponses(request, req => this.listConnectHarnesses(req));
  }

  /**
   * List the stream pools for a given compartment ID.
   * This operation uses {@link common.OciSdkDefaultRetryConfiguration} by default if no retry configuration is defined by the user.
   * @param ListStreamPoolsRequest
   * @return ListStreamPoolsResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/streaming/ListStreamPools.ts.html |here} to see how to use ListStreamPools API.
   */
  public async listStreamPools(
    listStreamPoolsRequest: requests.ListStreamPoolsRequest
  ): Promise<responses.ListStreamPoolsResponse> {
    if (this.logger) this.logger.debug("Calling operation StreamAdminClient#listStreamPools.");
    const operationName = "listStreamPools";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/streaming/20180418/StreamPoolSummary/ListStreamPools";
    const pathParams = {};

    const queryParams = {
      "compartmentId": listStreamPoolsRequest.compartmentId,
      "id": listStreamPoolsRequest.id,
      "name": listStreamPoolsRequest.name,
      "limit": listStreamPoolsRequest.limit,
      "page": listStreamPoolsRequest.page,
      "sortBy": listStreamPoolsRequest.sortBy,
      "sortOrder": listStreamPoolsRequest.sortOrder,
      "lifecycleState": listStreamPoolsRequest.lifecycleState
    };

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": listStreamPoolsRequest.opcRequestId
    };

    const specRetryConfiguration = common.OciSdkDefaultRetryConfiguration;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      listStreamPoolsRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/streampools",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.ListStreamPoolsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: model.StreamPoolSummary,
        type: "Array<model.StreamPoolSummary>",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-prev-page"),
            key: "opcPrevPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * NOTE: This function is deprecated in favor of listStreamPoolsRecordIterator function.
   * Creates a new async iterator which will iterate over the models.StreamPoolSummary objects
   * contained in responses from the listStreamPools operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllStreamPools(
    request: requests.ListStreamPoolsRequest
  ): AsyncIterableIterator<model.StreamPoolSummary> {
    return paginateRecords(request, req => this.listStreamPools(req));
  }

  /**
   * NOTE: This function is deprecated in favor of listStreamPoolsResponseIterator function.
   * Creates a new async iterator which will iterate over the responses received from the listStreamPools operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllStreamPoolsResponses(
    request: requests.ListStreamPoolsRequest
  ): AsyncIterableIterator<responses.ListStreamPoolsResponse> {
    return paginateResponses(request, req => this.listStreamPools(req));
  }

  /**
   * Creates a new async iterator which will iterate over the models.StreamPoolSummary objects
   * contained in responses from the listStreamPools operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listStreamPoolsRecordIterator(
    request: requests.ListStreamPoolsRequest
  ): AsyncIterableIterator<model.StreamPoolSummary> {
    return paginateRecords(request, req => this.listStreamPools(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listStreamPools operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listStreamPoolsResponseIterator(
    request: requests.ListStreamPoolsRequest
  ): AsyncIterableIterator<responses.ListStreamPoolsResponse> {
    return paginateResponses(request, req => this.listStreamPools(req));
  }

  /**
   * Lists the streams in the given compartment id.
   * If the compartment id is specified, it will list streams in the compartment, regardless of their stream pool.
   * If the stream pool id is specified, the action will be scoped to that stream pool.
   * The compartment id and stream pool id cannot be specified at the same time.
   *
   * This operation uses {@link common.OciSdkDefaultRetryConfiguration} by default if no retry configuration is defined by the user.
   * @param ListStreamsRequest
   * @return ListStreamsResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/streaming/ListStreams.ts.html |here} to see how to use ListStreams API.
   */
  public async listStreams(
    listStreamsRequest: requests.ListStreamsRequest
  ): Promise<responses.ListStreamsResponse> {
    if (this.logger) this.logger.debug("Calling operation StreamAdminClient#listStreams.");
    const operationName = "listStreams";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/streaming/20180418/StreamSummary/ListStreams";
    const pathParams = {};

    const queryParams = {
      "compartmentId": listStreamsRequest.compartmentId,
      "streamPoolId": listStreamsRequest.streamPoolId,
      "id": listStreamsRequest.id,
      "name": listStreamsRequest.name,
      "limit": listStreamsRequest.limit,
      "page": listStreamsRequest.page,
      "sortBy": listStreamsRequest.sortBy,
      "sortOrder": listStreamsRequest.sortOrder,
      "lifecycleState": listStreamsRequest.lifecycleState
    };

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": listStreamsRequest.opcRequestId
    };

    const specRetryConfiguration = common.OciSdkDefaultRetryConfiguration;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      listStreamsRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/streams",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.ListStreamsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: model.StreamSummary,
        type: "Array<model.StreamSummary>",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-prev-page"),
            key: "opcPrevPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * NOTE: This function is deprecated in favor of listStreamsRecordIterator function.
   * Creates a new async iterator which will iterate over the models.StreamSummary objects
   * contained in responses from the listStreams operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllStreams(
    request: requests.ListStreamsRequest
  ): AsyncIterableIterator<model.StreamSummary> {
    return paginateRecords(request, req => this.listStreams(req));
  }

  /**
   * NOTE: This function is deprecated in favor of listStreamsResponseIterator function.
   * Creates a new async iterator which will iterate over the responses received from the listStreams operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllStreamsResponses(
    request: requests.ListStreamsRequest
  ): AsyncIterableIterator<responses.ListStreamsResponse> {
    return paginateResponses(request, req => this.listStreams(req));
  }

  /**
   * Creates a new async iterator which will iterate over the models.StreamSummary objects
   * contained in responses from the listStreams operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listStreamsRecordIterator(
    request: requests.ListStreamsRequest
  ): AsyncIterableIterator<model.StreamSummary> {
    return paginateRecords(request, req => this.listStreams(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listStreams operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listStreamsResponseIterator(
    request: requests.ListStreamsRequest
  ): AsyncIterableIterator<responses.ListStreamsResponse> {
    return paginateResponses(request, req => this.listStreams(req));
  }

  /**
   * Updates the tags applied to the connect harness.
   *
   * This operation uses {@link common.OciSdkDefaultRetryConfiguration} by default if no retry configuration is defined by the user.
   * @param UpdateConnectHarnessRequest
   * @return UpdateConnectHarnessResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/streaming/UpdateConnectHarness.ts.html |here} to see how to use UpdateConnectHarness API.
   */
  public async updateConnectHarness(
    updateConnectHarnessRequest: requests.UpdateConnectHarnessRequest
  ): Promise<responses.UpdateConnectHarnessResponse> {
    if (this.logger) this.logger.debug("Calling operation StreamAdminClient#updateConnectHarness.");
    const operationName = "updateConnectHarness";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/streaming/20180418/ConnectHarness/UpdateConnectHarness";
    const pathParams = {
      "{connectHarnessId}": updateConnectHarnessRequest.connectHarnessId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": updateConnectHarnessRequest.opcRequestId,
      "if-match": updateConnectHarnessRequest.ifMatch
    };

    const specRetryConfiguration = common.OciSdkDefaultRetryConfiguration;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      updateConnectHarnessRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/connectharnesses/{connectHarnessId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateConnectHarnessRequest.updateConnectHarnessDetails,
        "UpdateConnectHarnessDetails",
        model.UpdateConnectHarnessDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateConnectHarnessResponse>{},
        body: await response.json(),
        bodyKey: "connectHarness",
        bodyModel: model.ConnectHarness,
        type: "model.ConnectHarness",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Updates the stream. Only specified values will be updated.
   *
   * This operation uses {@link common.OciSdkDefaultRetryConfiguration} by default if no retry configuration is defined by the user.
   * @param UpdateStreamRequest
   * @return UpdateStreamResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/streaming/UpdateStream.ts.html |here} to see how to use UpdateStream API.
   */
  public async updateStream(
    updateStreamRequest: requests.UpdateStreamRequest
  ): Promise<responses.UpdateStreamResponse> {
    if (this.logger) this.logger.debug("Calling operation StreamAdminClient#updateStream.");
    const operationName = "updateStream";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/streaming/20180418/Stream/UpdateStream";
    const pathParams = {
      "{streamId}": updateStreamRequest.streamId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": updateStreamRequest.opcRequestId,
      "if-match": updateStreamRequest.ifMatch
    };

    const specRetryConfiguration = common.OciSdkDefaultRetryConfiguration;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      updateStreamRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/streams/{streamId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateStreamRequest.updateStreamDetails,
        "UpdateStreamDetails",
        model.UpdateStreamDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateStreamResponse>{},
        body: await response.json(),
        bodyKey: "stream",
        bodyModel: model.Stream,
        type: "model.Stream",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Updates the specified stream pool.
   *
   * This operation uses {@link common.OciSdkDefaultRetryConfiguration} by default if no retry configuration is defined by the user.
   * @param UpdateStreamPoolRequest
   * @return UpdateStreamPoolResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/streaming/UpdateStreamPool.ts.html |here} to see how to use UpdateStreamPool API.
   */
  public async updateStreamPool(
    updateStreamPoolRequest: requests.UpdateStreamPoolRequest
  ): Promise<responses.UpdateStreamPoolResponse> {
    if (this.logger) this.logger.debug("Calling operation StreamAdminClient#updateStreamPool.");
    const operationName = "updateStreamPool";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/streaming/20180418/StreamPool/UpdateStreamPool";
    const pathParams = {
      "{streamPoolId}": updateStreamPoolRequest.streamPoolId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": updateStreamPoolRequest.opcRequestId,
      "if-match": updateStreamPoolRequest.ifMatch
    };

    const specRetryConfiguration = common.OciSdkDefaultRetryConfiguration;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      updateStreamPoolRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/streampools/{streamPoolId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateStreamPoolRequest.updateStreamPoolDetails,
        "UpdateStreamPoolDetails",
        model.UpdateStreamPoolDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateStreamPoolResponse>{},
        body: await response.json(),
        bodyKey: "streamPool",
        bodyModel: model.StreamPool,
        type: "model.StreamPool",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }
}
