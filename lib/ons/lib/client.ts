/**
 * Notifications API
 * Use the Notifications API to broadcast messages to distributed components by topic, using a publish-subscribe pattern.
For information about managing topics, subscriptions, and messages, see [Notifications Overview](https://docs.oracle.com/iaas/Content/Notification/Concepts/notificationoverview.htm).

 * OpenAPI spec version: 20181201
 * 
 *
 * NOTE: This class is auto generated by OracleSDKGenerator.
 * Do not edit the class manually.
 *
 * Copyright (c) 2020, 2025, Oracle and/or its affiliates.  All rights reserved.
 * This software is dual-licensed to you under the Universal Permissive License (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl or Apache License 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose either license.
 */

import common = require("oci-common");
import * as requests from "./request";
import * as model from "./model";
import * as responses from "./response";
import { paginateRecords, paginateResponses } from "oci-common";
import { NotificationDataPlaneWaiter } from "./notificationdataplane-waiter";
import {
  composeResponse,
  composeRequest,
  GenericRetrier,
  developerToolConfiguration
} from "oci-common";
const Breaker = require("opossum");

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum NotificationControlPlaneApiKeys {}
/**
 * This service client uses {@link common.CircuitBreaker.DefaultConfiguration} for all the operations by default if no circuit breaker configuration is defined by the user.
 */
export class NotificationControlPlaneClient {
  protected static serviceEndpointTemplate = "https://notification.{region}.{secondLevelDomain}";
  protected static endpointServiceName = "";
  protected "_realmSpecificEndpointTemplateEnabled": boolean | undefined = undefined;
  protected "_endpoint": string = "";
  protected "_defaultHeaders": any = {};
  protected "_clientConfiguration": common.ClientConfiguration;
  protected _circuitBreaker: typeof Breaker | null = null;
  protected _httpOptions: any = undefined;
  protected _bodyDuplexMode: any = undefined;
  public targetService = "NotificationControlPlane";
  protected _regionId: string = "";
  protected "_region": common.Region;
  protected _lastSetRegionOrRegionId: string = "";

  protected _httpClient: common.HttpClient;
  protected _authProvider: common.AuthenticationDetailsProvider | undefined;

  constructor(params: common.AuthParams, clientConfiguration?: common.ClientConfiguration) {
    const requestSigner = params.authenticationDetailsProvider
      ? new common.DefaultRequestSigner(params.authenticationDetailsProvider)
      : null;
    this._authProvider = params.authenticationDetailsProvider;
    if (clientConfiguration) {
      this._clientConfiguration = clientConfiguration;
      this._circuitBreaker = clientConfiguration.circuitBreaker
        ? clientConfiguration.circuitBreaker!.circuit
        : null;
      this._httpOptions = clientConfiguration.httpOptions
        ? clientConfiguration.httpOptions
        : undefined;
      this._bodyDuplexMode = clientConfiguration.bodyDuplexMode
        ? clientConfiguration.bodyDuplexMode
        : undefined;
    }

    if (!developerToolConfiguration.isServiceEnabled("ons")) {
      let errmsg =
        "The developerToolConfiguration configuration disabled this service, this behavior is controlled by developerToolConfiguration.ociEnabledServiceSet variable. Please check if your local developer_tool_configuration file has configured the service you're targeting or contact the cloud provider on the availability of this service : ";
      throw errmsg.concat("ons");
    }

    // if circuit breaker is not created, check if circuit breaker system is enabled to use default circuit breaker
    const specCircuitBreakerEnabled = true;
    if (
      !this._circuitBreaker &&
      common.utils.isCircuitBreakerSystemEnabled(clientConfiguration!) &&
      (specCircuitBreakerEnabled || common.CircuitBreaker.DefaultCircuitBreakerOverriden)
    ) {
      this._circuitBreaker = new common.CircuitBreaker().circuit;
    }
    this._httpClient =
      params.httpClient ||
      new common.FetchHttpClient(
        requestSigner,
        this._circuitBreaker,
        this._httpOptions,
        this._bodyDuplexMode
      );

    if (
      params.authenticationDetailsProvider &&
      common.isRegionProvider(params.authenticationDetailsProvider)
    ) {
      const provider: common.RegionProvider = params.authenticationDetailsProvider;
      if (provider.getRegion()) {
        this.region = provider.getRegion();
      }
    }
  }

  /**
   * Get the endpoint that is being used to call (ex, https://www.example.com).
   */
  public get endpoint() {
    return this._endpoint;
  }

  /**
   * Sets the endpoint to call (ex, https://www.example.com).
   * @param endpoint The endpoint of the service.
   */
  public set endpoint(endpoint: string) {
    this._endpoint = endpoint;
    this._endpoint = this._endpoint + "/20181201";
    if (this.logger)
      this.logger.info(`NotificationControlPlaneClient endpoint set to ${this._endpoint}`);
  }

  public get logger() {
    return common.LOG.logger;
  }

  /**
   * Determines whether realm specific endpoint should be used or not.
   * Set realmSpecificEndpointTemplateEnabled to "true" if the user wants to enable use of realm specific endpoint template, otherwise set it to "false"
   * @param realmSpecificEndpointTemplateEnabled flag to enable the use of realm specific endpoint template
   */
  public set useRealmSpecificEndpointTemplate(realmSpecificEndpointTemplateEnabled: boolean) {
    this._realmSpecificEndpointTemplateEnabled = realmSpecificEndpointTemplateEnabled;
    if (this.logger)
      this.logger.info(
        `realmSpecificEndpointTemplateEnabled set to ${this._realmSpecificEndpointTemplateEnabled}`
      );
    if (this._lastSetRegionOrRegionId === common.Region.REGION_STRING) {
      this.endpoint = common.EndpointBuilder.createEndpointFromRegion(
        NotificationControlPlaneClient.serviceEndpointTemplate,
        this._region,
        NotificationControlPlaneClient.endpointServiceName
      );
    } else if (this._lastSetRegionOrRegionId === common.Region.REGION_ID_STRING) {
      this.endpoint = common.EndpointBuilder.createEndpointFromRegionId(
        NotificationControlPlaneClient.serviceEndpointTemplate,
        this._regionId,
        NotificationControlPlaneClient.endpointServiceName
      );
    }
  }

  /**
   * Sets the region to call (ex, Region.US_PHOENIX_1).
   * Note, this will call {@link #endpoint(String) endpoint} after resolving the endpoint.
   * @param region The region of the service.
   */
  public set region(region: common.Region) {
    this._region = region;
    this.endpoint = common.EndpointBuilder.createEndpointFromRegion(
      NotificationControlPlaneClient.serviceEndpointTemplate,
      region,
      NotificationControlPlaneClient.endpointServiceName
    );
    this._lastSetRegionOrRegionId = common.Region.REGION_STRING;
  }

  /**
   * Sets the regionId to call (ex, 'us-phoenix-1').
   *
   * Note, this will first try to map the region ID to a known Region and call {@link #region(Region) region}.
   * If no known Region could be determined, it will create an endpoint assuming its in default Realm OC1
   * and then call {@link #endpoint(String) endpoint}.
   * @param regionId The public region ID.
   */
  public set regionId(regionId: string) {
    this._regionId = regionId;
    this.endpoint = common.EndpointBuilder.createEndpointFromRegionId(
      NotificationControlPlaneClient.serviceEndpointTemplate,
      regionId,
      NotificationControlPlaneClient.endpointServiceName
    );
    this._lastSetRegionOrRegionId = common.Region.REGION_ID_STRING;
  }

  /**
   * Shutdown the circuit breaker used by the client when it is no longer needed
   */
  public shutdownCircuitBreaker() {
    if (this._circuitBreaker) {
      this._circuitBreaker.shutdown();
    }
  }

  /**
   * Close the provider if possible which in turn shuts down any associated circuit breaker
   */
  public closeProvider() {
    if (this._authProvider) {
      if (this._authProvider instanceof common.AbstractRequestingAuthenticationDetailsProvider)
        (<common.AbstractRequestingAuthenticationDetailsProvider>(
          this._authProvider
        )).closeProvider();
    }
  }

  /**
   * Close the client once it is no longer needed
   */
  public close() {
    this.shutdownCircuitBreaker();
    this.closeProvider();
  }

  /**
     * Moves a topic into a different compartment within the same tenancy. For information about moving resources
* between compartments, see
* [Moving Resources to a Different Compartment](https://docs.oracle.com/iaas/Content/Identity/Tasks/managingcompartments.htm#moveRes).
* <p>
Transactions Per Minute (TPM) per-tenancy limit for this operation: 60.
* 
     * This operation does not retry by default if the user has not defined a retry configuration.
     * @param ChangeTopicCompartmentRequest
     * @return ChangeTopicCompartmentResponse
     * @throws OciError when an error occurs
     * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/ons/ChangeTopicCompartment.ts.html |here} to see how to use ChangeTopicCompartment API.
     */
  public async changeTopicCompartment(
    changeTopicCompartmentRequest: requests.ChangeTopicCompartmentRequest
  ): Promise<responses.ChangeTopicCompartmentResponse> {
    if (this.logger)
      this.logger.debug("Calling operation NotificationControlPlaneClient#changeTopicCompartment.");
    const operationName = "changeTopicCompartment";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/notification/20181201/NotificationTopic/ChangeTopicCompartment";
    const pathParams = {
      "{topicId}": changeTopicCompartmentRequest.topicId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-retry-token": changeTopicCompartmentRequest.opcRetryToken,
      "opc-request-id": changeTopicCompartmentRequest.opcRequestId,
      "if-match": changeTopicCompartmentRequest.ifMatch
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      changeTopicCompartmentRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/topics/{topicId}/actions/changeCompartment",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        changeTopicCompartmentRequest.changeTopicCompartmentDetails,
        "ChangeCompartmentDetails",
        model.ChangeCompartmentDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.ChangeTopicCompartmentResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
     * Creates a topic in the specified compartment. For general information about topics, see
* [Managing Topics and Subscriptions](https://docs.oracle.com/iaas/Content/Notification/Tasks/managingtopicsandsubscriptions.htm).
* <p>
For the purposes of access control, you must provide the OCID of the compartment where you want the topic to reside.
* For information about access control and compartments, see [Overview of the IAM Service](https://docs.oracle.com/iaas/Content/Identity/Concepts/overview.htm).
* <p>
You must specify a display name for the topic.
* <p>
All Oracle Cloud Infrastructure resources, including topics, get an Oracle-assigned, unique ID called an
* Oracle Cloud Identifier (OCID). When you create a resource, you can find its OCID in the response. You can also
* retrieve a resource's OCID by using a List API operation on that resource type, or by viewing the resource in the
* Console. For more information, see [Resource Identifiers](https://docs.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
* <p>
Transactions Per Minute (TPM) per-tenancy limit for this operation: 60.
* 
     * This operation does not retry by default if the user has not defined a retry configuration.
     * @param CreateTopicRequest
     * @return CreateTopicResponse
     * @throws OciError when an error occurs
     * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/ons/CreateTopic.ts.html |here} to see how to use CreateTopic API.
     */
  public async createTopic(
    createTopicRequest: requests.CreateTopicRequest
  ): Promise<responses.CreateTopicResponse> {
    if (this.logger)
      this.logger.debug("Calling operation NotificationControlPlaneClient#createTopic.");
    const operationName = "createTopic";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/notification/20181201/NotificationTopic/CreateTopic";
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-retry-token": createTopicRequest.opcRetryToken,
      "opc-request-id": createTopicRequest.opcRequestId
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      createTopicRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/topics",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createTopicRequest.createTopicDetails,
        "CreateTopicDetails",
        model.CreateTopicDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateTopicResponse>{},
        body: await response.json(),
        bodyKey: "notificationTopic",
        bodyModel: model.NotificationTopic,
        type: "model.NotificationTopic",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
     * Deletes the specified topic.
* <p>
Transactions Per Minute (TPM) per-tenancy limit for this operation: 60.
* 
     * This operation does not retry by default if the user has not defined a retry configuration.
     * @param DeleteTopicRequest
     * @return DeleteTopicResponse
     * @throws OciError when an error occurs
     * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/ons/DeleteTopic.ts.html |here} to see how to use DeleteTopic API.
     */
  public async deleteTopic(
    deleteTopicRequest: requests.DeleteTopicRequest
  ): Promise<responses.DeleteTopicResponse> {
    if (this.logger)
      this.logger.debug("Calling operation NotificationControlPlaneClient#deleteTopic.");
    const operationName = "deleteTopic";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/notification/20181201/NotificationTopic/DeleteTopic";
    const pathParams = {
      "{topicId}": deleteTopicRequest.topicId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": deleteTopicRequest.opcRequestId,
      "if-match": deleteTopicRequest.ifMatch
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      deleteTopicRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/topics/{topicId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteTopicResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Gets the specified topic's configuration information.
   *
   * This operation does not retry by default if the user has not defined a retry configuration.
   * @param GetTopicRequest
   * @return GetTopicResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/ons/GetTopic.ts.html |here} to see how to use GetTopic API.
   */
  public async getTopic(
    getTopicRequest: requests.GetTopicRequest
  ): Promise<responses.GetTopicResponse> {
    if (this.logger)
      this.logger.debug("Calling operation NotificationControlPlaneClient#getTopic.");
    const operationName = "getTopic";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/notification/20181201/NotificationTopic/GetTopic";
    const pathParams = {
      "{topicId}": getTopicRequest.topicId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": getTopicRequest.opcRequestId
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      getTopicRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/topics/{topicId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.GetTopicResponse>{},
        body: await response.json(),
        bodyKey: "notificationTopic",
        bodyModel: model.NotificationTopic,
        type: "model.NotificationTopic",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
     * Lists topics in the specified compartment.
* <p>
Transactions Per Minute (TPM) per-tenancy limit for this operation: 120.
* 
     * This operation does not retry by default if the user has not defined a retry configuration.
     * @param ListTopicsRequest
     * @return ListTopicsResponse
     * @throws OciError when an error occurs
     * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/ons/ListTopics.ts.html |here} to see how to use ListTopics API.
     */
  public async listTopics(
    listTopicsRequest: requests.ListTopicsRequest
  ): Promise<responses.ListTopicsResponse> {
    if (this.logger)
      this.logger.debug("Calling operation NotificationControlPlaneClient#listTopics.");
    const operationName = "listTopics";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/notification/20181201/NotificationTopic/ListTopics";
    const pathParams = {};

    const queryParams = {
      "compartmentId": listTopicsRequest.compartmentId,
      "id": listTopicsRequest.id,
      "name": listTopicsRequest.name,
      "page": listTopicsRequest.page,
      "limit": listTopicsRequest.limit,
      "sortBy": listTopicsRequest.sortBy,
      "sortOrder": listTopicsRequest.sortOrder,
      "lifecycleState": listTopicsRequest.lifecycleState
    };

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": listTopicsRequest.opcRequestId
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      listTopicsRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/topics",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.ListTopicsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: model.NotificationTopicSummary,
        type: "Array<model.NotificationTopicSummary>",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-previous-page"),
            key: "opcPreviousPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * NOTE: This function is deprecated in favor of listTopicsRecordIterator function.
   * Creates a new async iterator which will iterate over the models.NotificationTopicSummary objects
   * contained in responses from the listTopics operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllTopics(
    request: requests.ListTopicsRequest
  ): AsyncIterableIterator<model.NotificationTopicSummary> {
    return paginateRecords(request, req => this.listTopics(req));
  }

  /**
   * NOTE: This function is deprecated in favor of listTopicsResponseIterator function.
   * Creates a new async iterator which will iterate over the responses received from the listTopics operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllTopicsResponses(
    request: requests.ListTopicsRequest
  ): AsyncIterableIterator<responses.ListTopicsResponse> {
    return paginateResponses(request, req => this.listTopics(req));
  }

  /**
   * Creates a new async iterator which will iterate over the models.NotificationTopicSummary objects
   * contained in responses from the listTopics operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listTopicsRecordIterator(
    request: requests.ListTopicsRequest
  ): AsyncIterableIterator<model.NotificationTopicSummary> {
    return paginateRecords(request, req => this.listTopics(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listTopics operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listTopicsResponseIterator(
    request: requests.ListTopicsRequest
  ): AsyncIterableIterator<responses.ListTopicsResponse> {
    return paginateResponses(request, req => this.listTopics(req));
  }

  /**
     * Updates the specified topic's configuration.
* <p>
Transactions Per Minute (TPM) per-tenancy limit for this operation: 60.
* 
     * This operation does not retry by default if the user has not defined a retry configuration.
     * @param UpdateTopicRequest
     * @return UpdateTopicResponse
     * @throws OciError when an error occurs
     * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/ons/UpdateTopic.ts.html |here} to see how to use UpdateTopic API.
     */
  public async updateTopic(
    updateTopicRequest: requests.UpdateTopicRequest
  ): Promise<responses.UpdateTopicResponse> {
    if (this.logger)
      this.logger.debug("Calling operation NotificationControlPlaneClient#updateTopic.");
    const operationName = "updateTopic";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/notification/20181201/NotificationTopic/UpdateTopic";
    const pathParams = {
      "{topicId}": updateTopicRequest.topicId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": updateTopicRequest.opcRequestId,
      "if-match": updateTopicRequest.ifMatch
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      updateTopicRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/topics/{topicId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateTopicRequest.topicAttributesDetails,
        "TopicAttributesDetails",
        model.TopicAttributesDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateTopicResponse>{},
        body: await response.json(),
        bodyKey: "notificationTopic",
        bodyModel: model.NotificationTopic,
        type: "model.NotificationTopic",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }
}
export enum NotificationDataPlaneApiKeys {}
/**
 * This service client uses {@link common.CircuitBreaker.DefaultConfiguration} for all the operations by default if no circuit breaker configuration is defined by the user.
 */
export class NotificationDataPlaneClient {
  protected static serviceEndpointTemplate = "https://notification.{region}.{secondLevelDomain}";
  protected static endpointServiceName = "";
  protected "_realmSpecificEndpointTemplateEnabled": boolean | undefined = undefined;
  protected "_endpoint": string = "";
  protected "_defaultHeaders": any = {};
  protected "_waiters": NotificationDataPlaneWaiter;
  protected "_clientConfiguration": common.ClientConfiguration;
  protected _circuitBreaker: typeof Breaker | null = null;
  protected _httpOptions: any = undefined;
  protected _bodyDuplexMode: any = undefined;
  public targetService = "NotificationDataPlane";
  protected _regionId: string = "";
  protected "_region": common.Region;
  protected _lastSetRegionOrRegionId: string = "";

  protected _httpClient: common.HttpClient;
  protected _authProvider: common.AuthenticationDetailsProvider | undefined;

  constructor(params: common.AuthParams, clientConfiguration?: common.ClientConfiguration) {
    const requestSigner = params.authenticationDetailsProvider
      ? new common.DefaultRequestSigner(params.authenticationDetailsProvider)
      : null;
    this._authProvider = params.authenticationDetailsProvider;
    if (clientConfiguration) {
      this._clientConfiguration = clientConfiguration;
      this._circuitBreaker = clientConfiguration.circuitBreaker
        ? clientConfiguration.circuitBreaker!.circuit
        : null;
      this._httpOptions = clientConfiguration.httpOptions
        ? clientConfiguration.httpOptions
        : undefined;
      this._bodyDuplexMode = clientConfiguration.bodyDuplexMode
        ? clientConfiguration.bodyDuplexMode
        : undefined;
    }

    if (!developerToolConfiguration.isServiceEnabled("ons")) {
      let errmsg =
        "The developerToolConfiguration configuration disabled this service, this behavior is controlled by developerToolConfiguration.ociEnabledServiceSet variable. Please check if your local developer_tool_configuration file has configured the service you're targeting or contact the cloud provider on the availability of this service : ";
      throw errmsg.concat("ons");
    }

    // if circuit breaker is not created, check if circuit breaker system is enabled to use default circuit breaker
    const specCircuitBreakerEnabled = true;
    if (
      !this._circuitBreaker &&
      common.utils.isCircuitBreakerSystemEnabled(clientConfiguration!) &&
      (specCircuitBreakerEnabled || common.CircuitBreaker.DefaultCircuitBreakerOverriden)
    ) {
      this._circuitBreaker = new common.CircuitBreaker().circuit;
    }
    this._httpClient =
      params.httpClient ||
      new common.FetchHttpClient(
        requestSigner,
        this._circuitBreaker,
        this._httpOptions,
        this._bodyDuplexMode
      );

    if (
      params.authenticationDetailsProvider &&
      common.isRegionProvider(params.authenticationDetailsProvider)
    ) {
      const provider: common.RegionProvider = params.authenticationDetailsProvider;
      if (provider.getRegion()) {
        this.region = provider.getRegion();
      }
    }
  }

  /**
   * Get the endpoint that is being used to call (ex, https://www.example.com).
   */
  public get endpoint() {
    return this._endpoint;
  }

  /**
   * Sets the endpoint to call (ex, https://www.example.com).
   * @param endpoint The endpoint of the service.
   */
  public set endpoint(endpoint: string) {
    this._endpoint = endpoint;
    this._endpoint = this._endpoint + "/20181201";
    if (this.logger)
      this.logger.info(`NotificationDataPlaneClient endpoint set to ${this._endpoint}`);
  }

  public get logger() {
    return common.LOG.logger;
  }

  /**
   * Determines whether realm specific endpoint should be used or not.
   * Set realmSpecificEndpointTemplateEnabled to "true" if the user wants to enable use of realm specific endpoint template, otherwise set it to "false"
   * @param realmSpecificEndpointTemplateEnabled flag to enable the use of realm specific endpoint template
   */
  public set useRealmSpecificEndpointTemplate(realmSpecificEndpointTemplateEnabled: boolean) {
    this._realmSpecificEndpointTemplateEnabled = realmSpecificEndpointTemplateEnabled;
    if (this.logger)
      this.logger.info(
        `realmSpecificEndpointTemplateEnabled set to ${this._realmSpecificEndpointTemplateEnabled}`
      );
    if (this._lastSetRegionOrRegionId === common.Region.REGION_STRING) {
      this.endpoint = common.EndpointBuilder.createEndpointFromRegion(
        NotificationDataPlaneClient.serviceEndpointTemplate,
        this._region,
        NotificationDataPlaneClient.endpointServiceName
      );
    } else if (this._lastSetRegionOrRegionId === common.Region.REGION_ID_STRING) {
      this.endpoint = common.EndpointBuilder.createEndpointFromRegionId(
        NotificationDataPlaneClient.serviceEndpointTemplate,
        this._regionId,
        NotificationDataPlaneClient.endpointServiceName
      );
    }
  }

  /**
   * Sets the region to call (ex, Region.US_PHOENIX_1).
   * Note, this will call {@link #endpoint(String) endpoint} after resolving the endpoint.
   * @param region The region of the service.
   */
  public set region(region: common.Region) {
    this._region = region;
    this.endpoint = common.EndpointBuilder.createEndpointFromRegion(
      NotificationDataPlaneClient.serviceEndpointTemplate,
      region,
      NotificationDataPlaneClient.endpointServiceName
    );
    this._lastSetRegionOrRegionId = common.Region.REGION_STRING;
  }

  /**
   * Sets the regionId to call (ex, 'us-phoenix-1').
   *
   * Note, this will first try to map the region ID to a known Region and call {@link #region(Region) region}.
   * If no known Region could be determined, it will create an endpoint assuming its in default Realm OC1
   * and then call {@link #endpoint(String) endpoint}.
   * @param regionId The public region ID.
   */
  public set regionId(regionId: string) {
    this._regionId = regionId;
    this.endpoint = common.EndpointBuilder.createEndpointFromRegionId(
      NotificationDataPlaneClient.serviceEndpointTemplate,
      regionId,
      NotificationDataPlaneClient.endpointServiceName
    );
    this._lastSetRegionOrRegionId = common.Region.REGION_ID_STRING;
  }

  /**
   * Creates a new NotificationDataPlaneWaiter for resources for this service.
   *
   * @param config The waiter configuration for termination and delay strategy
   * @return The service waiters.
   */
  public createWaiters(config?: common.WaiterConfiguration): NotificationDataPlaneWaiter {
    this._waiters = new NotificationDataPlaneWaiter(this, config);
    return this._waiters;
  }

  /**
   * Gets the waiters available for resources for this service.
   *
   * @return The service waiters.
   */
  public getWaiters(): NotificationDataPlaneWaiter {
    if (this._waiters) {
      return this._waiters;
    }
    throw Error("Waiters do not exist. Please create waiters.");
  }

  /**
   * Shutdown the circuit breaker used by the client when it is no longer needed
   */
  public shutdownCircuitBreaker() {
    if (this._circuitBreaker) {
      this._circuitBreaker.shutdown();
    }
  }

  /**
   * Close the provider if possible which in turn shuts down any associated circuit breaker
   */
  public closeProvider() {
    if (this._authProvider) {
      if (this._authProvider instanceof common.AbstractRequestingAuthenticationDetailsProvider)
        (<common.AbstractRequestingAuthenticationDetailsProvider>(
          this._authProvider
        )).closeProvider();
    }
  }

  /**
   * Close the client once it is no longer needed
   */
  public close() {
    this.shutdownCircuitBreaker();
    this.closeProvider();
  }

  /**
     * Moves a subscription into a different compartment within the same tenancy. For information about moving
* resources between compartments, see
* [Moving Resources to a Different Compartment](https://docs.oracle.com/iaas/Content/Identity/Tasks/managingcompartments.htm#moveRes).
* <p>
Transactions Per Minute (TPM) per-tenancy limit for this operation: 60.
* 
     * This operation does not retry by default if the user has not defined a retry configuration.
     * @param ChangeSubscriptionCompartmentRequest
     * @return ChangeSubscriptionCompartmentResponse
     * @throws OciError when an error occurs
     * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/ons/ChangeSubscriptionCompartment.ts.html |here} to see how to use ChangeSubscriptionCompartment API.
     */
  public async changeSubscriptionCompartment(
    changeSubscriptionCompartmentRequest: requests.ChangeSubscriptionCompartmentRequest
  ): Promise<responses.ChangeSubscriptionCompartmentResponse> {
    if (this.logger)
      this.logger.debug(
        "Calling operation NotificationDataPlaneClient#changeSubscriptionCompartment."
      );
    const operationName = "changeSubscriptionCompartment";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/notification/20181201/Subscription/ChangeSubscriptionCompartment";
    const pathParams = {
      "{subscriptionId}": changeSubscriptionCompartmentRequest.subscriptionId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-retry-token": changeSubscriptionCompartmentRequest.opcRetryToken,
      "opc-request-id": changeSubscriptionCompartmentRequest.opcRequestId,
      "if-match": changeSubscriptionCompartmentRequest.ifMatch
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      changeSubscriptionCompartmentRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/subscriptions/{subscriptionId}/actions/changeCompartment",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        changeSubscriptionCompartmentRequest.changeSubscriptionCompartmentDetails,
        "ChangeCompartmentDetails",
        model.ChangeCompartmentDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.ChangeSubscriptionCompartmentResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
     * Creates a subscription for the specified topic and sends a subscription confirmation URL to the endpoint. The subscription remains in \"Pending\" status until it has been confirmed.
* For information about confirming subscriptions, see
* [To confirm a subscription](https://docs.oracle.com/iaas/Content/Notification/Tasks/managingtopicsandsubscriptions.htm#confirmSub).
* <p>
Transactions Per Minute (TPM) per-tenancy limit for this operation: 60.
* 
     * This operation does not retry by default if the user has not defined a retry configuration.
     * @param CreateSubscriptionRequest
     * @return CreateSubscriptionResponse
     * @throws OciError when an error occurs
     * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/ons/CreateSubscription.ts.html |here} to see how to use CreateSubscription API.
     */
  public async createSubscription(
    createSubscriptionRequest: requests.CreateSubscriptionRequest
  ): Promise<responses.CreateSubscriptionResponse> {
    if (this.logger)
      this.logger.debug("Calling operation NotificationDataPlaneClient#createSubscription.");
    const operationName = "createSubscription";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/notification/20181201/Subscription/CreateSubscription";
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-retry-token": createSubscriptionRequest.opcRetryToken,
      "opc-request-id": createSubscriptionRequest.opcRequestId
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      createSubscriptionRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/subscriptions",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createSubscriptionRequest.createSubscriptionDetails,
        "CreateSubscriptionDetails",
        model.CreateSubscriptionDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateSubscriptionResponse>{},
        body: await response.json(),
        bodyKey: "subscription",
        bodyModel: model.Subscription,
        type: "model.Subscription",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
     * Deletes the specified subscription.
* <p>
Transactions Per Minute (TPM) per-tenancy limit for this operation: 60.
* 
     * This operation does not retry by default if the user has not defined a retry configuration.
     * @param DeleteSubscriptionRequest
     * @return DeleteSubscriptionResponse
     * @throws OciError when an error occurs
     * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/ons/DeleteSubscription.ts.html |here} to see how to use DeleteSubscription API.
     */
  public async deleteSubscription(
    deleteSubscriptionRequest: requests.DeleteSubscriptionRequest
  ): Promise<responses.DeleteSubscriptionResponse> {
    if (this.logger)
      this.logger.debug("Calling operation NotificationDataPlaneClient#deleteSubscription.");
    const operationName = "deleteSubscription";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/notification/20181201/Subscription/DeleteSubscription";
    const pathParams = {
      "{subscriptionId}": deleteSubscriptionRequest.subscriptionId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": deleteSubscriptionRequest.opcRequestId,
      "if-match": deleteSubscriptionRequest.ifMatch
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      deleteSubscriptionRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/subscriptions/{subscriptionId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteSubscriptionResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
     * Gets the confirmation details for the specified subscription.
* <p>
Transactions Per Minute (TPM) per-tenancy limit for this operation: 60.
* 
     * This operation does not retry by default if the user has not defined a retry configuration.
     * @param GetConfirmSubscriptionRequest
     * @return GetConfirmSubscriptionResponse
     * @throws OciError when an error occurs
     * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/ons/GetConfirmSubscription.ts.html |here} to see how to use GetConfirmSubscription API.
     */
  public async getConfirmSubscription(
    getConfirmSubscriptionRequest: requests.GetConfirmSubscriptionRequest
  ): Promise<responses.GetConfirmSubscriptionResponse> {
    if (this.logger)
      this.logger.debug("Calling operation NotificationDataPlaneClient#getConfirmSubscription.");
    const operationName = "getConfirmSubscription";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/notification/20181201/Subscription/GetConfirmSubscription";
    const pathParams = {
      "{id}": getConfirmSubscriptionRequest.id
    };

    const queryParams = {
      "token": getConfirmSubscriptionRequest.token,
      "protocol": getConfirmSubscriptionRequest.protocol
    };

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": getConfirmSubscriptionRequest.opcRequestId
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      getConfirmSubscriptionRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/subscriptions/{id}/confirmation",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.GetConfirmSubscriptionResponse>{},
        body: await response.json(),
        bodyKey: "confirmationResult",
        bodyModel: model.ConfirmationResult,
        type: "model.ConfirmationResult",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
     * Gets the specified subscription's configuration information.
* <p>
Transactions Per Minute (TPM) per-tenancy limit for this operation: 60.
* 
     * This operation does not retry by default if the user has not defined a retry configuration.
     * @param GetSubscriptionRequest
     * @return GetSubscriptionResponse
     * @throws OciError when an error occurs
     * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/ons/GetSubscription.ts.html |here} to see how to use GetSubscription API.
     */
  public async getSubscription(
    getSubscriptionRequest: requests.GetSubscriptionRequest
  ): Promise<responses.GetSubscriptionResponse> {
    if (this.logger)
      this.logger.debug("Calling operation NotificationDataPlaneClient#getSubscription.");
    const operationName = "getSubscription";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/notification/20181201/Subscription/GetSubscription";
    const pathParams = {
      "{subscriptionId}": getSubscriptionRequest.subscriptionId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": getSubscriptionRequest.opcRequestId
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      getSubscriptionRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/subscriptions/{subscriptionId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.GetSubscriptionResponse>{},
        body: await response.json(),
        bodyKey: "subscription",
        bodyModel: model.Subscription,
        type: "model.Subscription",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
     * Unsubscribes the subscription from the topic.
* <p>
Transactions Per Minute (TPM) per-tenancy limit for this operation: 60.
* 
     * This operation does not retry by default if the user has not defined a retry configuration.
     * @param GetUnsubscriptionRequest
     * @return GetUnsubscriptionResponse
     * @throws OciError when an error occurs
     * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/ons/GetUnsubscription.ts.html |here} to see how to use GetUnsubscription API.
     */
  public async getUnsubscription(
    getUnsubscriptionRequest: requests.GetUnsubscriptionRequest
  ): Promise<responses.GetUnsubscriptionResponse> {
    if (this.logger)
      this.logger.debug("Calling operation NotificationDataPlaneClient#getUnsubscription.");
    const operationName = "getUnsubscription";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/notification/20181201/Subscription/GetUnsubscription";
    const pathParams = {
      "{id}": getUnsubscriptionRequest.id
    };

    const queryParams = {
      "token": getUnsubscriptionRequest.token,
      "protocol": getUnsubscriptionRequest.protocol
    };

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": getUnsubscriptionRequest.opcRequestId
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      getUnsubscriptionRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/subscriptions/{id}/unsubscription",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.GetUnsubscriptionResponse>{},
        body: await response.json(),
        bodyKey: "value",
        bodyModel: "string",
        type: "string",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
     * Lists the subscriptions in the specified compartment or topic.
* <p>
Transactions Per Minute (TPM) per-tenancy limit for this operation: 60.
* 
     * This operation does not retry by default if the user has not defined a retry configuration.
     * @param ListSubscriptionsRequest
     * @return ListSubscriptionsResponse
     * @throws OciError when an error occurs
     * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/ons/ListSubscriptions.ts.html |here} to see how to use ListSubscriptions API.
     */
  public async listSubscriptions(
    listSubscriptionsRequest: requests.ListSubscriptionsRequest
  ): Promise<responses.ListSubscriptionsResponse> {
    if (this.logger)
      this.logger.debug("Calling operation NotificationDataPlaneClient#listSubscriptions.");
    const operationName = "listSubscriptions";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/notification/20181201/Subscription/ListSubscriptions";
    const pathParams = {};

    const queryParams = {
      "compartmentId": listSubscriptionsRequest.compartmentId,
      "topicId": listSubscriptionsRequest.topicId,
      "page": listSubscriptionsRequest.page,
      "limit": listSubscriptionsRequest.limit
    };

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": listSubscriptionsRequest.opcRequestId
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      listSubscriptionsRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/subscriptions",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.ListSubscriptionsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: model.SubscriptionSummary,
        type: "Array<model.SubscriptionSummary>",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * NOTE: This function is deprecated in favor of listSubscriptionsRecordIterator function.
   * Creates a new async iterator which will iterate over the models.SubscriptionSummary objects
   * contained in responses from the listSubscriptions operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllSubscriptions(
    request: requests.ListSubscriptionsRequest
  ): AsyncIterableIterator<model.SubscriptionSummary> {
    return paginateRecords(request, req => this.listSubscriptions(req));
  }

  /**
   * NOTE: This function is deprecated in favor of listSubscriptionsResponseIterator function.
   * Creates a new async iterator which will iterate over the responses received from the listSubscriptions operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllSubscriptionsResponses(
    request: requests.ListSubscriptionsRequest
  ): AsyncIterableIterator<responses.ListSubscriptionsResponse> {
    return paginateResponses(request, req => this.listSubscriptions(req));
  }

  /**
   * Creates a new async iterator which will iterate over the models.SubscriptionSummary objects
   * contained in responses from the listSubscriptions operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listSubscriptionsRecordIterator(
    request: requests.ListSubscriptionsRequest
  ): AsyncIterableIterator<model.SubscriptionSummary> {
    return paginateRecords(request, req => this.listSubscriptions(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listSubscriptions operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listSubscriptionsResponseIterator(
    request: requests.ListSubscriptionsRequest
  ): AsyncIterableIterator<responses.ListSubscriptionsResponse> {
    return paginateResponses(request, req => this.listSubscriptions(req));
  }

  /**
     * Publishes a message to the specified topic.
* <p>
The topic endpoint is required for this operation.
* To get the topic endpoint, use {@link #getTopic(GetTopicRequest) getTopic}
* and review the `apiEndpoint` value in the response ({@link NotificationTopic}).
* <p>
Limits information follows.
* <p>
Message size limit per request: 64KB.
* <p>
Message delivery rate limit per endpoint: 60 messages per minute for HTTP-based protocols, 10 messages per minute for the `EMAIL` protocol.
* HTTP-based protocols use URL endpoints that begin with \"http:\" or \"https:\".
* <p>
Transactions Per Minute (TPM) per-tenancy limit for this operation: 60 per topic. (This TPM limit represents messages per minute.)
* <p>
For more information about publishing messages, see [Publishing Messages](https://docs.oracle.com/iaas/Content/Notification/Tasks/publishingmessages.htm).
* For steps to request a limit increase, see [Requesting a Service Limit Increase](https://docs.oracle.com/iaas/Content/General/Concepts/servicelimits.htm#three).
* 
     * This operation does not retry by default if the user has not defined a retry configuration.
     * @param PublishMessageRequest
     * @return PublishMessageResponse
     * @throws OciError when an error occurs
     * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/ons/PublishMessage.ts.html |here} to see how to use PublishMessage API.
     */
  public async publishMessage(
    publishMessageRequest: requests.PublishMessageRequest
  ): Promise<responses.PublishMessageResponse> {
    if (this.logger)
      this.logger.debug("Calling operation NotificationDataPlaneClient#publishMessage.");
    const operationName = "publishMessage";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/notification/20181201/NotificationTopic/PublishMessage";
    const pathParams = {
      "{topicId}": publishMessageRequest.topicId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": publishMessageRequest.opcRequestId,
      "messageType": publishMessageRequest.messageType
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      publishMessageRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/topics/{topicId}/messages",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        publishMessageRequest.messageDetails,
        "MessageDetails",
        model.MessageDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.PublishMessageResponse>{},
        body: await response.json(),
        bodyKey: "publishResult",
        bodyModel: model.PublishResult,
        type: "model.PublishResult",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
     * Resends the confirmation details for the specified subscription.
* <p>
Transactions Per Minute (TPM) per-tenancy limit for this operation: 60.
* 
     * This operation does not retry by default if the user has not defined a retry configuration.
     * @param ResendSubscriptionConfirmationRequest
     * @return ResendSubscriptionConfirmationResponse
     * @throws OciError when an error occurs
     * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/ons/ResendSubscriptionConfirmation.ts.html |here} to see how to use ResendSubscriptionConfirmation API.
     */
  public async resendSubscriptionConfirmation(
    resendSubscriptionConfirmationRequest: requests.ResendSubscriptionConfirmationRequest
  ): Promise<responses.ResendSubscriptionConfirmationResponse> {
    if (this.logger)
      this.logger.debug(
        "Calling operation NotificationDataPlaneClient#resendSubscriptionConfirmation."
      );
    const operationName = "resendSubscriptionConfirmation";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/notification/20181201/Subscription/ResendSubscriptionConfirmation";
    const pathParams = {
      "{id}": resendSubscriptionConfirmationRequest.id
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": resendSubscriptionConfirmationRequest.opcRequestId
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      resendSubscriptionConfirmationRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/subscriptions/{id}/resendConfirmation",
      method: "POST",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.ResendSubscriptionConfirmationResponse>{},
        body: await response.json(),
        bodyKey: "subscription",
        bodyModel: model.Subscription,
        type: "model.Subscription",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
     * Updates the specified subscription's configuration.
* <p>
Transactions Per Minute (TPM) per-tenancy limit for this operation: 60.
* 
     * This operation does not retry by default if the user has not defined a retry configuration.
     * @param UpdateSubscriptionRequest
     * @return UpdateSubscriptionResponse
     * @throws OciError when an error occurs
     * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/ons/UpdateSubscription.ts.html |here} to see how to use UpdateSubscription API.
     */
  public async updateSubscription(
    updateSubscriptionRequest: requests.UpdateSubscriptionRequest
  ): Promise<responses.UpdateSubscriptionResponse> {
    if (this.logger)
      this.logger.debug("Calling operation NotificationDataPlaneClient#updateSubscription.");
    const operationName = "updateSubscription";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/notification/20181201/Subscription/UpdateSubscription";
    const pathParams = {
      "{subscriptionId}": updateSubscriptionRequest.subscriptionId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": updateSubscriptionRequest.opcRequestId,
      "if-match": updateSubscriptionRequest.ifMatch
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      updateSubscriptionRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/subscriptions/{subscriptionId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateSubscriptionRequest.updateSubscriptionDetails,
        "UpdateSubscriptionDetails",
        model.UpdateSubscriptionDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateSubscriptionResponse>{},
        body: await response.json(),
        bodyKey: "updateSubscriptionDetails",
        bodyModel: model.UpdateSubscriptionDetails,
        type: "model.UpdateSubscriptionDetails",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }
}
