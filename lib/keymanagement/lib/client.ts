/**
 * Vault Key Management API
 * Use the Key Management API to manage vaults and keys. For more information, see [Managing Vaults](https://docs.oracle.com/iaas/Content/KeyManagement/Tasks/managingvaults.htm) and [Managing Keys](https://docs.oracle.com/iaas/Content/KeyManagement/Tasks/managingkeys.htm).

 * OpenAPI spec version: release
 * Contact: sparta_kms_us_grp@oracle.com
 *
 * NOTE: This class is auto generated by OracleSDKGenerator.
 * Do not edit the class manually.
 *
 * Copyright (c) 2020, 2025, Oracle and/or its affiliates.  All rights reserved.
 * This software is dual-licensed to you under the Universal Permissive License (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl or Apache License 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose either license.
 */

import common = require("oci-common");
import * as requests from "./request";
import * as model from "./model";
import * as responses from "./response";
import { paginateRecords, paginateResponses } from "oci-common";
import { EkmWaiter } from "./ekm-waiter";
import { KmsHsmClusterWaiter } from "./kmshsmcluster-waiter";
import { KmsManagementWaiter } from "./kmsmanagement-waiter";
import { KmsVaultWaiter } from "./kmsvault-waiter";
import {
  composeResponse,
  composeRequest,
  GenericRetrier,
  developerToolConfiguration
} from "oci-common";
const Breaker = require("opossum");

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum EkmApiKeys {}
/**
 * This service client uses {@link common.CircuitBreaker.DefaultConfiguration} for all the operations by default if no circuit breaker configuration is defined by the user.
 */
export class EkmClient {
  protected static serviceEndpointTemplate = "https://kms.{region}.{secondLevelDomain}";
  protected static endpointServiceName = "";
  protected "_realmSpecificEndpointTemplateEnabled": boolean | undefined = undefined;
  protected "_endpoint": string = "";
  protected "_defaultHeaders": any = {};
  protected "_waiters": EkmWaiter;
  protected "_clientConfiguration": common.ClientConfiguration;
  protected _circuitBreaker: typeof Breaker | null = null;
  protected _httpOptions: any = undefined;
  protected _bodyDuplexMode: any = undefined;
  public targetService = "Ekm";
  protected _regionId: string = "";
  protected "_region": common.Region;
  protected _lastSetRegionOrRegionId: string = "";

  protected _httpClient: common.HttpClient;
  protected _authProvider: common.AuthenticationDetailsProvider | undefined;

  constructor(params: common.AuthParams, clientConfiguration?: common.ClientConfiguration) {
    const requestSigner = params.authenticationDetailsProvider
      ? new common.DefaultRequestSigner(params.authenticationDetailsProvider)
      : null;
    this._authProvider = params.authenticationDetailsProvider;
    if (clientConfiguration) {
      this._clientConfiguration = clientConfiguration;
      this._circuitBreaker = clientConfiguration.circuitBreaker
        ? clientConfiguration.circuitBreaker!.circuit
        : null;
      this._httpOptions = clientConfiguration.httpOptions
        ? clientConfiguration.httpOptions
        : undefined;
      this._bodyDuplexMode = clientConfiguration.bodyDuplexMode
        ? clientConfiguration.bodyDuplexMode
        : undefined;
    }

    if (!developerToolConfiguration.isServiceEnabled("keymanagement")) {
      let errmsg =
        "The developerToolConfiguration configuration disabled this service, this behavior is controlled by developerToolConfiguration.ociEnabledServiceSet variable. Please check if your local developer_tool_configuration file has configured the service you're targeting or contact the cloud provider on the availability of this service : ";
      throw errmsg.concat("keymanagement");
    }

    // if circuit breaker is not created, check if circuit breaker system is enabled to use default circuit breaker
    const specCircuitBreakerEnabled = true;
    if (
      !this._circuitBreaker &&
      common.utils.isCircuitBreakerSystemEnabled(clientConfiguration!) &&
      (specCircuitBreakerEnabled || common.CircuitBreaker.DefaultCircuitBreakerOverriden)
    ) {
      this._circuitBreaker = new common.CircuitBreaker().circuit;
    }
    this._httpClient =
      params.httpClient ||
      new common.FetchHttpClient(
        requestSigner,
        this._circuitBreaker,
        this._httpOptions,
        this._bodyDuplexMode
      );

    if (
      params.authenticationDetailsProvider &&
      common.isRegionProvider(params.authenticationDetailsProvider)
    ) {
      const provider: common.RegionProvider = params.authenticationDetailsProvider;
      if (provider.getRegion()) {
        this.region = provider.getRegion();
      }
    }
  }

  /**
   * Get the endpoint that is being used to call (ex, https://www.example.com).
   */
  public get endpoint() {
    return this._endpoint;
  }

  /**
   * Sets the endpoint to call (ex, https://www.example.com).
   * @param endpoint The endpoint of the service.
   */
  public set endpoint(endpoint: string) {
    this._endpoint = endpoint;
    if (this.logger) this.logger.info(`EkmClient endpoint set to ${this._endpoint}`);
  }

  public get logger() {
    return common.LOG.logger;
  }

  /**
   * Determines whether realm specific endpoint should be used or not.
   * Set realmSpecificEndpointTemplateEnabled to "true" if the user wants to enable use of realm specific endpoint template, otherwise set it to "false"
   * @param realmSpecificEndpointTemplateEnabled flag to enable the use of realm specific endpoint template
   */
  public set useRealmSpecificEndpointTemplate(realmSpecificEndpointTemplateEnabled: boolean) {
    this._realmSpecificEndpointTemplateEnabled = realmSpecificEndpointTemplateEnabled;
    if (this.logger)
      this.logger.info(
        `realmSpecificEndpointTemplateEnabled set to ${this._realmSpecificEndpointTemplateEnabled}`
      );
    if (this._lastSetRegionOrRegionId === common.Region.REGION_STRING) {
      this.endpoint = common.EndpointBuilder.createEndpointFromRegion(
        EkmClient.serviceEndpointTemplate,
        this._region,
        EkmClient.endpointServiceName
      );
    } else if (this._lastSetRegionOrRegionId === common.Region.REGION_ID_STRING) {
      this.endpoint = common.EndpointBuilder.createEndpointFromRegionId(
        EkmClient.serviceEndpointTemplate,
        this._regionId,
        EkmClient.endpointServiceName
      );
    }
  }

  /**
   * Sets the region to call (ex, Region.US_PHOENIX_1).
   * Note, this will call {@link #endpoint(String) endpoint} after resolving the endpoint.
   * @param region The region of the service.
   */
  public set region(region: common.Region) {
    this._region = region;
    this.endpoint = common.EndpointBuilder.createEndpointFromRegion(
      EkmClient.serviceEndpointTemplate,
      region,
      EkmClient.endpointServiceName
    );
    this._lastSetRegionOrRegionId = common.Region.REGION_STRING;
  }

  /**
   * Sets the regionId to call (ex, 'us-phoenix-1').
   *
   * Note, this will first try to map the region ID to a known Region and call {@link #region(Region) region}.
   * If no known Region could be determined, it will create an endpoint assuming its in default Realm OC1
   * and then call {@link #endpoint(String) endpoint}.
   * @param regionId The public region ID.
   */
  public set regionId(regionId: string) {
    this._regionId = regionId;
    this.endpoint = common.EndpointBuilder.createEndpointFromRegionId(
      EkmClient.serviceEndpointTemplate,
      regionId,
      EkmClient.endpointServiceName
    );
    this._lastSetRegionOrRegionId = common.Region.REGION_ID_STRING;
  }

  /**
   * Creates a new EkmWaiter for resources for this service.
   *
   * @param config The waiter configuration for termination and delay strategy
   * @return The service waiters.
   */
  public createWaiters(config?: common.WaiterConfiguration): EkmWaiter {
    this._waiters = new EkmWaiter(this, config);
    return this._waiters;
  }

  /**
   * Gets the waiters available for resources for this service.
   *
   * @return The service waiters.
   */
  public getWaiters(): EkmWaiter {
    if (this._waiters) {
      return this._waiters;
    }
    throw Error("Waiters do not exist. Please create waiters.");
  }

  /**
   * Shutdown the circuit breaker used by the client when it is no longer needed
   */
  public shutdownCircuitBreaker() {
    if (this._circuitBreaker) {
      this._circuitBreaker.shutdown();
    }
  }

  /**
   * Close the provider if possible which in turn shuts down any associated circuit breaker
   */
  public closeProvider() {
    if (this._authProvider) {
      if (this._authProvider instanceof common.AbstractRequestingAuthenticationDetailsProvider)
        (<common.AbstractRequestingAuthenticationDetailsProvider>(
          this._authProvider
        )).closeProvider();
    }
  }

  /**
   * Close the client once it is no longer needed
   */
  public close() {
    this.shutdownCircuitBreaker();
    this.closeProvider();
  }

  /**
   * Create a new EKMS private endpoint used to connect to external key manager system
   * This operation does not retry by default if the user has not defined a retry configuration.
   * @param CreateEkmsPrivateEndpointRequest
   * @return CreateEkmsPrivateEndpointResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/keymanagement/CreateEkmsPrivateEndpoint.ts.html |here} to see how to use CreateEkmsPrivateEndpoint API.
   */
  public async createEkmsPrivateEndpoint(
    createEkmsPrivateEndpointRequest: requests.CreateEkmsPrivateEndpointRequest
  ): Promise<responses.CreateEkmsPrivateEndpointResponse> {
    if (this.logger) this.logger.debug("Calling operation EkmClient#createEkmsPrivateEndpoint.");
    const operationName = "createEkmsPrivateEndpoint";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/key/release/EkmsPrivateEndpoint/CreateEkmsPrivateEndpoint";
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": createEkmsPrivateEndpointRequest.opcRequestId,
      "opc-retry-token": createEkmsPrivateEndpointRequest.opcRetryToken
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      createEkmsPrivateEndpointRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/20180608/ekmsPrivateEndpoints",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createEkmsPrivateEndpointRequest.createEkmsPrivateEndpointDetails,
        "CreateEkmsPrivateEndpointDetails",
        model.CreateEkmsPrivateEndpointDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateEkmsPrivateEndpointResponse>{},
        body: await response.json(),
        bodyKey: "ekmsPrivateEndpoint",
        bodyModel: model.EkmsPrivateEndpoint,
        type: "model.EkmsPrivateEndpoint",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Deletes EKMS private endpoint by identifier.
   * This operation does not retry by default if the user has not defined a retry configuration.
   * @param DeleteEkmsPrivateEndpointRequest
   * @return DeleteEkmsPrivateEndpointResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/keymanagement/DeleteEkmsPrivateEndpoint.ts.html |here} to see how to use DeleteEkmsPrivateEndpoint API.
   */
  public async deleteEkmsPrivateEndpoint(
    deleteEkmsPrivateEndpointRequest: requests.DeleteEkmsPrivateEndpointRequest
  ): Promise<responses.DeleteEkmsPrivateEndpointResponse> {
    if (this.logger) this.logger.debug("Calling operation EkmClient#deleteEkmsPrivateEndpoint.");
    const operationName = "deleteEkmsPrivateEndpoint";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/key/release/EkmsPrivateEndpoint/DeleteEkmsPrivateEndpoint";
    const pathParams = {
      "{ekmsPrivateEndpointId}": deleteEkmsPrivateEndpointRequest.ekmsPrivateEndpointId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "if-match": deleteEkmsPrivateEndpointRequest.ifMatch,
      "opc-request-id": deleteEkmsPrivateEndpointRequest.opcRequestId
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      deleteEkmsPrivateEndpointRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/20180608/ekmsPrivateEndpoints/{ekmsPrivateEndpointId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteEkmsPrivateEndpointResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Gets a specific EKMS private by identifier.
   * This operation does not retry by default if the user has not defined a retry configuration.
   * @param GetEkmsPrivateEndpointRequest
   * @return GetEkmsPrivateEndpointResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/keymanagement/GetEkmsPrivateEndpoint.ts.html |here} to see how to use GetEkmsPrivateEndpoint API.
   */
  public async getEkmsPrivateEndpoint(
    getEkmsPrivateEndpointRequest: requests.GetEkmsPrivateEndpointRequest
  ): Promise<responses.GetEkmsPrivateEndpointResponse> {
    if (this.logger) this.logger.debug("Calling operation EkmClient#getEkmsPrivateEndpoint.");
    const operationName = "getEkmsPrivateEndpoint";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/key/release/EkmsPrivateEndpoint/GetEkmsPrivateEndpoint";
    const pathParams = {
      "{ekmsPrivateEndpointId}": getEkmsPrivateEndpointRequest.ekmsPrivateEndpointId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": getEkmsPrivateEndpointRequest.opcRequestId
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      getEkmsPrivateEndpointRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/20180608/ekmsPrivateEndpoints/{ekmsPrivateEndpointId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.GetEkmsPrivateEndpointResponse>{},
        body: await response.json(),
        bodyKey: "ekmsPrivateEndpoint",
        bodyModel: model.EkmsPrivateEndpoint,
        type: "model.EkmsPrivateEndpoint",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Returns a list of all the EKMS private endpoints in the specified compartment.
   *
   * This operation does not retry by default if the user has not defined a retry configuration.
   * @param ListEkmsPrivateEndpointsRequest
   * @return ListEkmsPrivateEndpointsResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/keymanagement/ListEkmsPrivateEndpoints.ts.html |here} to see how to use ListEkmsPrivateEndpoints API.
   */
  public async listEkmsPrivateEndpoints(
    listEkmsPrivateEndpointsRequest: requests.ListEkmsPrivateEndpointsRequest
  ): Promise<responses.ListEkmsPrivateEndpointsResponse> {
    if (this.logger) this.logger.debug("Calling operation EkmClient#listEkmsPrivateEndpoints.");
    const operationName = "listEkmsPrivateEndpoints";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/key/release/EkmsPrivateEndpointSummary/ListEkmsPrivateEndpoints";
    const pathParams = {};

    const queryParams = {
      "compartmentId": listEkmsPrivateEndpointsRequest.compartmentId,
      "limit": listEkmsPrivateEndpointsRequest.limit,
      "page": listEkmsPrivateEndpointsRequest.page,
      "sortOrder": listEkmsPrivateEndpointsRequest.sortOrder,
      "sortBy": listEkmsPrivateEndpointsRequest.sortBy
    };

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": listEkmsPrivateEndpointsRequest.opcRequestId
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      listEkmsPrivateEndpointsRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/20180608/ekmsPrivateEndpoints",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.ListEkmsPrivateEndpointsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: model.EkmsPrivateEndpointSummary,
        type: "Array<model.EkmsPrivateEndpointSummary>",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * NOTE: This function is deprecated in favor of listEkmsPrivateEndpointsRecordIterator function.
   * Creates a new async iterator which will iterate over the models.EkmsPrivateEndpointSummary objects
   * contained in responses from the listEkmsPrivateEndpoints operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllEkmsPrivateEndpoints(
    request: requests.ListEkmsPrivateEndpointsRequest
  ): AsyncIterableIterator<model.EkmsPrivateEndpointSummary> {
    return paginateRecords(request, req => this.listEkmsPrivateEndpoints(req));
  }

  /**
   * NOTE: This function is deprecated in favor of listEkmsPrivateEndpointsResponseIterator function.
   * Creates a new async iterator which will iterate over the responses received from the listEkmsPrivateEndpoints operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllEkmsPrivateEndpointsResponses(
    request: requests.ListEkmsPrivateEndpointsRequest
  ): AsyncIterableIterator<responses.ListEkmsPrivateEndpointsResponse> {
    return paginateResponses(request, req => this.listEkmsPrivateEndpoints(req));
  }

  /**
   * Creates a new async iterator which will iterate over the models.EkmsPrivateEndpointSummary objects
   * contained in responses from the listEkmsPrivateEndpoints operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listEkmsPrivateEndpointsRecordIterator(
    request: requests.ListEkmsPrivateEndpointsRequest
  ): AsyncIterableIterator<model.EkmsPrivateEndpointSummary> {
    return paginateRecords(request, req => this.listEkmsPrivateEndpoints(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listEkmsPrivateEndpoints operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listEkmsPrivateEndpointsResponseIterator(
    request: requests.ListEkmsPrivateEndpointsRequest
  ): AsyncIterableIterator<responses.ListEkmsPrivateEndpointsResponse> {
    return paginateResponses(request, req => this.listEkmsPrivateEndpoints(req));
  }

  /**
   * Updates EKMS private endpoint.
   * This operation does not retry by default if the user has not defined a retry configuration.
   * @param UpdateEkmsPrivateEndpointRequest
   * @return UpdateEkmsPrivateEndpointResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/keymanagement/UpdateEkmsPrivateEndpoint.ts.html |here} to see how to use UpdateEkmsPrivateEndpoint API.
   */
  public async updateEkmsPrivateEndpoint(
    updateEkmsPrivateEndpointRequest: requests.UpdateEkmsPrivateEndpointRequest
  ): Promise<responses.UpdateEkmsPrivateEndpointResponse> {
    if (this.logger) this.logger.debug("Calling operation EkmClient#updateEkmsPrivateEndpoint.");
    const operationName = "updateEkmsPrivateEndpoint";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/key/release/EkmsPrivateEndpoint/UpdateEkmsPrivateEndpoint";
    const pathParams = {
      "{ekmsPrivateEndpointId}": updateEkmsPrivateEndpointRequest.ekmsPrivateEndpointId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "if-match": updateEkmsPrivateEndpointRequest.ifMatch,
      "opc-request-id": updateEkmsPrivateEndpointRequest.opcRequestId
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      updateEkmsPrivateEndpointRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/20180608/ekmsPrivateEndpoints/{ekmsPrivateEndpointId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateEkmsPrivateEndpointRequest.updateEkmsPrivateEndpointDetails,
        "UpdateEkmsPrivateEndpointDetails",
        model.UpdateEkmsPrivateEndpointDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateEkmsPrivateEndpointResponse>{},
        body: await response.json(),
        bodyKey: "ekmsPrivateEndpoint",
        bodyModel: model.EkmsPrivateEndpoint,
        type: "model.EkmsPrivateEndpoint",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }
}
export enum KmsCryptoApiKeys {}
/**
 * This service client uses {@link common.CircuitBreaker.DefaultConfiguration} for all the operations by default if no circuit breaker configuration is defined by the user.
 */
export class KmsCryptoClient {
  protected static serviceEndpointTemplate = "https://kms.{region}.{secondLevelDomain}";
  protected static endpointServiceName = "";
  protected "_realmSpecificEndpointTemplateEnabled": boolean | undefined = undefined;
  protected "_endpoint": string = "";
  protected "_defaultHeaders": any = {};
  protected "_clientConfiguration": common.ClientConfiguration;
  protected _circuitBreaker: typeof Breaker | null = null;
  protected _httpOptions: any = undefined;
  protected _bodyDuplexMode: any = undefined;
  public targetService = "KmsCrypto";

  protected _httpClient: common.HttpClient;
  protected _authProvider: common.AuthenticationDetailsProvider | undefined;

  constructor(params: common.AuthParams, clientConfiguration?: common.ClientConfiguration) {
    const requestSigner = params.authenticationDetailsProvider
      ? new common.DefaultRequestSigner(params.authenticationDetailsProvider)
      : null;
    this._authProvider = params.authenticationDetailsProvider;
    if (clientConfiguration) {
      this._clientConfiguration = clientConfiguration;
      this._circuitBreaker = clientConfiguration.circuitBreaker
        ? clientConfiguration.circuitBreaker!.circuit
        : null;
      this._httpOptions = clientConfiguration.httpOptions
        ? clientConfiguration.httpOptions
        : undefined;
      this._bodyDuplexMode = clientConfiguration.bodyDuplexMode
        ? clientConfiguration.bodyDuplexMode
        : undefined;
    }

    if (!developerToolConfiguration.isServiceEnabled("keymanagement")) {
      let errmsg =
        "The developerToolConfiguration configuration disabled this service, this behavior is controlled by developerToolConfiguration.ociEnabledServiceSet variable. Please check if your local developer_tool_configuration file has configured the service you're targeting or contact the cloud provider on the availability of this service : ";
      throw errmsg.concat("keymanagement");
    }

    // if circuit breaker is not created, check if circuit breaker system is enabled to use default circuit breaker
    const specCircuitBreakerEnabled = true;
    if (
      !this._circuitBreaker &&
      common.utils.isCircuitBreakerSystemEnabled(clientConfiguration!) &&
      (specCircuitBreakerEnabled || common.CircuitBreaker.DefaultCircuitBreakerOverriden)
    ) {
      this._circuitBreaker = new common.CircuitBreaker().circuit;
    }
    this._httpClient =
      params.httpClient ||
      new common.FetchHttpClient(
        requestSigner,
        this._circuitBreaker,
        this._httpOptions,
        this._bodyDuplexMode
      );
  }

  /**
   * Get the endpoint that is being used to call (ex, https://www.example.com).
   */
  public get endpoint() {
    return this._endpoint;
  }

  /**
   * Sets the endpoint to call (ex, https://www.example.com).
   * @param endpoint The endpoint of the service.
   */
  public set endpoint(endpoint: string) {
    this._endpoint = endpoint;
    if (this.logger) this.logger.info(`KmsCryptoClient endpoint set to ${this._endpoint}`);
  }

  public get logger() {
    return common.LOG.logger;
  }

  /**
   * Determines whether realm specific endpoint should be used or not.
   * Set realmSpecificEndpointTemplateEnabled to "true" if the user wants to enable use of realm specific endpoint template, otherwise set it to "false"
   * @param realmSpecificEndpointTemplateEnabled flag to enable the use of realm specific endpoint template
   */
  public set useRealmSpecificEndpointTemplate(realmSpecificEndpointTemplateEnabled: boolean) {
    this._realmSpecificEndpointTemplateEnabled = realmSpecificEndpointTemplateEnabled;
    if (this.logger)
      this.logger.info(
        `realmSpecificEndpointTemplateEnabled set to ${this._realmSpecificEndpointTemplateEnabled}`
      );
  }

  /**
   * Shutdown the circuit breaker used by the client when it is no longer needed
   */
  public shutdownCircuitBreaker() {
    if (this._circuitBreaker) {
      this._circuitBreaker.shutdown();
    }
  }

  /**
   * Close the provider if possible which in turn shuts down any associated circuit breaker
   */
  public closeProvider() {
    if (this._authProvider) {
      if (this._authProvider instanceof common.AbstractRequestingAuthenticationDetailsProvider)
        (<common.AbstractRequestingAuthenticationDetailsProvider>(
          this._authProvider
        )).closeProvider();
    }
  }

  /**
   * Close the client once it is no longer needed
   */
  public close() {
    this.shutdownCircuitBreaker();
    this.closeProvider();
  }

  /**
   * Decrypts data using the given [DecryptDataDetails](https://docs.oracle.com/iaas/api/#/en/key/latest/datatypes/DecryptDataDetails) resource.
   *
   * This operation does not retry by default if the user has not defined a retry configuration.
   * @param DecryptRequest
   * @return DecryptResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/keymanagement/Decrypt.ts.html |here} to see how to use Decrypt API.
   */
  public async decrypt(
    decryptRequest: requests.DecryptRequest
  ): Promise<responses.DecryptResponse> {
    if (this.logger) this.logger.debug("Calling operation KmsCryptoClient#decrypt.");
    const operationName = "decrypt";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/key/release/DecryptedData/Decrypt";
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": decryptRequest.opcRequestId
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      decryptRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/20180608/decrypt",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        decryptRequest.decryptDataDetails,
        "DecryptDataDetails",
        model.DecryptDataDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.DecryptResponse>{},
        body: await response.json(),
        bodyKey: "decryptedData",
        bodyModel: model.DecryptedData,
        type: "model.DecryptedData",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Encrypts data using the given [EncryptDataDetails](https://docs.oracle.com/iaas/api/#/en/key/latest/datatypes/EncryptDataDetails) resource.
   * Plaintext included in the example request is a base64-encoded value of a UTF-8 string.
   *
   * This operation does not retry by default if the user has not defined a retry configuration.
   * @param EncryptRequest
   * @return EncryptResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/keymanagement/Encrypt.ts.html |here} to see how to use Encrypt API.
   */
  public async encrypt(
    encryptRequest: requests.EncryptRequest
  ): Promise<responses.EncryptResponse> {
    if (this.logger) this.logger.debug("Calling operation KmsCryptoClient#encrypt.");
    const operationName = "encrypt";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/key/release/EncryptedData/Encrypt";
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": encryptRequest.opcRequestId
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      encryptRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/20180608/encrypt",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        encryptRequest.encryptDataDetails,
        "EncryptDataDetails",
        model.EncryptDataDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.EncryptResponse>{},
        body: await response.json(),
        bodyKey: "encryptedData",
        bodyModel: model.EncryptedData,
        type: "model.EncryptedData",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Exports a specific version of a master encryption key according to the details of the request. For their protection,
   * keys that you create and store on a hardware security module (HSM) can never leave the HSM. You can only export keys
   * stored on the server. For export, the key version is encrypted by an RSA public key that you provide.
   * This operation is not supported for keys having protection mode `EXTERNAL`.
   *
   * This operation does not retry by default if the user has not defined a retry configuration.
   * @param ExportKeyRequest
   * @return ExportKeyResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/keymanagement/ExportKey.ts.html |here} to see how to use ExportKey API.
   */
  public async exportKey(
    exportKeyRequest: requests.ExportKeyRequest
  ): Promise<responses.ExportKeyResponse> {
    if (this.logger) this.logger.debug("Calling operation KmsCryptoClient#exportKey.");
    const operationName = "exportKey";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/key/release/ExportedKeyData/ExportKey";
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      exportKeyRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/20180608/exportKey",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        exportKeyRequest.exportKeyDetails,
        "ExportKeyDetails",
        model.ExportKeyDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.ExportKeyResponse>{},
        body: await response.json(),
        bodyKey: "exportedKeyData",
        bodyModel: model.ExportedKeyData,
        type: "model.ExportedKeyData",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Generates a key that you can use to encrypt or decrypt data.
   *
   * This operation does not retry by default if the user has not defined a retry configuration.
   * @param GenerateDataEncryptionKeyRequest
   * @return GenerateDataEncryptionKeyResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/keymanagement/GenerateDataEncryptionKey.ts.html |here} to see how to use GenerateDataEncryptionKey API.
   */
  public async generateDataEncryptionKey(
    generateDataEncryptionKeyRequest: requests.GenerateDataEncryptionKeyRequest
  ): Promise<responses.GenerateDataEncryptionKeyResponse> {
    if (this.logger)
      this.logger.debug("Calling operation KmsCryptoClient#generateDataEncryptionKey.");
    const operationName = "generateDataEncryptionKey";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/key/release/GeneratedKey/GenerateDataEncryptionKey";
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": generateDataEncryptionKeyRequest.opcRequestId
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      generateDataEncryptionKeyRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/20180608/generateDataEncryptionKey",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        generateDataEncryptionKeyRequest.generateKeyDetails,
        "GenerateKeyDetails",
        model.GenerateKeyDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.GenerateDataEncryptionKeyResponse>{},
        body: await response.json(),
        bodyKey: "generatedKey",
        bodyModel: model.GeneratedKey,
        type: "model.GeneratedKey",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Creates a digital signature for a message or message digest by using the private key of a public-private key pair,
   * also known as an asymmetric key. To verify the generated signature, you can use the [Verify](https://docs.oracle.com/iaas/api/#/en/key/latest/VerifiedData/Verify)
   * operation. Or, if you want to validate the signature outside of the service, you can do so by using the public key of the same asymmetric key.
   * This operation is not supported for keys having protection mode `EXTERNAL`.
   *
   * This operation does not retry by default if the user has not defined a retry configuration.
   * @param SignRequest
   * @return SignResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/keymanagement/Sign.ts.html |here} to see how to use Sign API.
   */
  public async sign(signRequest: requests.SignRequest): Promise<responses.SignResponse> {
    if (this.logger) this.logger.debug("Calling operation KmsCryptoClient#sign.");
    const operationName = "sign";
    const apiReferenceLink = "https://docs.oracle.com/iaas/api/#/en/key/release/SignedData/Sign";
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": signRequest.opcRequestId
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      signRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/20180608/sign",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        signRequest.signDataDetails,
        "SignDataDetails",
        model.SignDataDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.SignResponse>{},
        body: await response.json(),
        bodyKey: "signedData",
        bodyModel: model.SignedData,
        type: "model.SignedData",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Verifies a digital signature that was generated by the [Sign](https://docs.oracle.com/iaas/api/#/en/key/latest/SignedData/Sign) operation
   * by using the public key of the same asymmetric key that was used to sign the data. If you want to validate the
   * digital signature outside of the service, you can do so by using the public key of the asymmetric key.
   * This operation is not supported for keys having protection mode `EXTERNAL`.
   *
   * This operation does not retry by default if the user has not defined a retry configuration.
   * @param VerifyRequest
   * @return VerifyResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/keymanagement/Verify.ts.html |here} to see how to use Verify API.
   */
  public async verify(verifyRequest: requests.VerifyRequest): Promise<responses.VerifyResponse> {
    if (this.logger) this.logger.debug("Calling operation KmsCryptoClient#verify.");
    const operationName = "verify";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/key/release/VerifiedData/Verify";
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": verifyRequest.opcRequestId
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      verifyRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/20180608/verify",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        verifyRequest.verifyDataDetails,
        "VerifyDataDetails",
        model.VerifyDataDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.VerifyResponse>{},
        body: await response.json(),
        bodyKey: "verifiedData",
        bodyModel: model.VerifiedData,
        type: "model.VerifiedData",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }
}
export enum KmsHsmClusterApiKeys {}
/**
 * This service client uses {@link common.CircuitBreaker.DefaultConfiguration} for all the operations by default if no circuit breaker configuration is defined by the user.
 */
export class KmsHsmClusterClient {
  protected static serviceEndpointTemplate = "https://kms.{region}.{secondLevelDomain}";
  protected static endpointServiceName = "";
  protected "_realmSpecificEndpointTemplateEnabled": boolean | undefined = undefined;
  protected "_endpoint": string = "";
  protected "_defaultHeaders": any = {};
  protected "_waiters": KmsHsmClusterWaiter;
  protected "_clientConfiguration": common.ClientConfiguration;
  protected _circuitBreaker: typeof Breaker | null = null;
  protected _httpOptions: any = undefined;
  protected _bodyDuplexMode: any = undefined;
  public targetService = "KmsHsmCluster";
  protected _regionId: string = "";
  protected "_region": common.Region;
  protected _lastSetRegionOrRegionId: string = "";

  protected _httpClient: common.HttpClient;
  protected _authProvider: common.AuthenticationDetailsProvider | undefined;

  constructor(params: common.AuthParams, clientConfiguration?: common.ClientConfiguration) {
    const requestSigner = params.authenticationDetailsProvider
      ? new common.DefaultRequestSigner(params.authenticationDetailsProvider)
      : null;
    this._authProvider = params.authenticationDetailsProvider;
    if (clientConfiguration) {
      this._clientConfiguration = clientConfiguration;
      this._circuitBreaker = clientConfiguration.circuitBreaker
        ? clientConfiguration.circuitBreaker!.circuit
        : null;
      this._httpOptions = clientConfiguration.httpOptions
        ? clientConfiguration.httpOptions
        : undefined;
      this._bodyDuplexMode = clientConfiguration.bodyDuplexMode
        ? clientConfiguration.bodyDuplexMode
        : undefined;
    }

    if (!developerToolConfiguration.isServiceEnabled("keymanagement")) {
      let errmsg =
        "The developerToolConfiguration configuration disabled this service, this behavior is controlled by developerToolConfiguration.ociEnabledServiceSet variable. Please check if your local developer_tool_configuration file has configured the service you're targeting or contact the cloud provider on the availability of this service : ";
      throw errmsg.concat("keymanagement");
    }

    // if circuit breaker is not created, check if circuit breaker system is enabled to use default circuit breaker
    const specCircuitBreakerEnabled = true;
    if (
      !this._circuitBreaker &&
      common.utils.isCircuitBreakerSystemEnabled(clientConfiguration!) &&
      (specCircuitBreakerEnabled || common.CircuitBreaker.DefaultCircuitBreakerOverriden)
    ) {
      this._circuitBreaker = new common.CircuitBreaker().circuit;
    }
    this._httpClient =
      params.httpClient ||
      new common.FetchHttpClient(
        requestSigner,
        this._circuitBreaker,
        this._httpOptions,
        this._bodyDuplexMode
      );

    if (
      params.authenticationDetailsProvider &&
      common.isRegionProvider(params.authenticationDetailsProvider)
    ) {
      const provider: common.RegionProvider = params.authenticationDetailsProvider;
      if (provider.getRegion()) {
        this.region = provider.getRegion();
      }
    }
  }

  /**
   * Get the endpoint that is being used to call (ex, https://www.example.com).
   */
  public get endpoint() {
    return this._endpoint;
  }

  /**
   * Sets the endpoint to call (ex, https://www.example.com).
   * @param endpoint The endpoint of the service.
   */
  public set endpoint(endpoint: string) {
    this._endpoint = endpoint;
    if (this.logger) this.logger.info(`KmsHsmClusterClient endpoint set to ${this._endpoint}`);
  }

  public get logger() {
    return common.LOG.logger;
  }

  /**
   * Determines whether realm specific endpoint should be used or not.
   * Set realmSpecificEndpointTemplateEnabled to "true" if the user wants to enable use of realm specific endpoint template, otherwise set it to "false"
   * @param realmSpecificEndpointTemplateEnabled flag to enable the use of realm specific endpoint template
   */
  public set useRealmSpecificEndpointTemplate(realmSpecificEndpointTemplateEnabled: boolean) {
    this._realmSpecificEndpointTemplateEnabled = realmSpecificEndpointTemplateEnabled;
    if (this.logger)
      this.logger.info(
        `realmSpecificEndpointTemplateEnabled set to ${this._realmSpecificEndpointTemplateEnabled}`
      );
    if (this._lastSetRegionOrRegionId === common.Region.REGION_STRING) {
      this.endpoint = common.EndpointBuilder.createEndpointFromRegion(
        KmsHsmClusterClient.serviceEndpointTemplate,
        this._region,
        KmsHsmClusterClient.endpointServiceName
      );
    } else if (this._lastSetRegionOrRegionId === common.Region.REGION_ID_STRING) {
      this.endpoint = common.EndpointBuilder.createEndpointFromRegionId(
        KmsHsmClusterClient.serviceEndpointTemplate,
        this._regionId,
        KmsHsmClusterClient.endpointServiceName
      );
    }
  }

  /**
   * Sets the region to call (ex, Region.US_PHOENIX_1).
   * Note, this will call {@link #endpoint(String) endpoint} after resolving the endpoint.
   * @param region The region of the service.
   */
  public set region(region: common.Region) {
    this._region = region;
    this.endpoint = common.EndpointBuilder.createEndpointFromRegion(
      KmsHsmClusterClient.serviceEndpointTemplate,
      region,
      KmsHsmClusterClient.endpointServiceName
    );
    this._lastSetRegionOrRegionId = common.Region.REGION_STRING;
  }

  /**
   * Sets the regionId to call (ex, 'us-phoenix-1').
   *
   * Note, this will first try to map the region ID to a known Region and call {@link #region(Region) region}.
   * If no known Region could be determined, it will create an endpoint assuming its in default Realm OC1
   * and then call {@link #endpoint(String) endpoint}.
   * @param regionId The public region ID.
   */
  public set regionId(regionId: string) {
    this._regionId = regionId;
    this.endpoint = common.EndpointBuilder.createEndpointFromRegionId(
      KmsHsmClusterClient.serviceEndpointTemplate,
      regionId,
      KmsHsmClusterClient.endpointServiceName
    );
    this._lastSetRegionOrRegionId = common.Region.REGION_ID_STRING;
  }

  /**
   * Creates a new KmsHsmClusterWaiter for resources for this service.
   *
   * @param config The waiter configuration for termination and delay strategy
   * @return The service waiters.
   */
  public createWaiters(config?: common.WaiterConfiguration): KmsHsmClusterWaiter {
    this._waiters = new KmsHsmClusterWaiter(this, config);
    return this._waiters;
  }

  /**
   * Gets the waiters available for resources for this service.
   *
   * @return The service waiters.
   */
  public getWaiters(): KmsHsmClusterWaiter {
    if (this._waiters) {
      return this._waiters;
    }
    throw Error("Waiters do not exist. Please create waiters.");
  }

  /**
   * Shutdown the circuit breaker used by the client when it is no longer needed
   */
  public shutdownCircuitBreaker() {
    if (this._circuitBreaker) {
      this._circuitBreaker.shutdown();
    }
  }

  /**
   * Close the provider if possible which in turn shuts down any associated circuit breaker
   */
  public closeProvider() {
    if (this._authProvider) {
      if (this._authProvider instanceof common.AbstractRequestingAuthenticationDetailsProvider)
        (<common.AbstractRequestingAuthenticationDetailsProvider>(
          this._authProvider
        )).closeProvider();
    }
  }

  /**
   * Close the client once it is no longer needed
   */
  public close() {
    this.shutdownCircuitBreaker();
    this.closeProvider();
  }

  /**
   * Cancels deletion of specified HSM Cluster, restores it and associated HSM partitions to pre-deletion states.
   * This operation does not retry by default if the user has not defined a retry configuration.
   * @param CancelHsmClusterDeletionRequest
   * @return CancelHsmClusterDeletionResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/keymanagement/CancelHsmClusterDeletion.ts.html |here} to see how to use CancelHsmClusterDeletion API.
   */
  public async cancelHsmClusterDeletion(
    cancelHsmClusterDeletionRequest: requests.CancelHsmClusterDeletionRequest
  ): Promise<responses.CancelHsmClusterDeletionResponse> {
    if (this.logger)
      this.logger.debug("Calling operation KmsHsmClusterClient#cancelHsmClusterDeletion.");
    const operationName = "cancelHsmClusterDeletion";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/key/release/HsmCluster/CancelHsmClusterDeletion";
    const pathParams = {
      "{hsmClusterId}": cancelHsmClusterDeletionRequest.hsmClusterId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "if-match": cancelHsmClusterDeletionRequest.ifMatch,
      "opc-request-id": cancelHsmClusterDeletionRequest.opcRequestId,
      "opc-retry-token": cancelHsmClusterDeletionRequest.opcRetryToken
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      cancelHsmClusterDeletionRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/20180608/hsmClusters/{hsmClusterId}/actions/cancelDeletion",
      method: "POST",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.CancelHsmClusterDeletionResponse>{},
        body: await response.json(),
        bodyKey: "hsmCluster",
        bodyModel: model.HsmCluster,
        type: "model.HsmCluster",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Moves a HSM Cluster resource to a different compartment within the same tenancy.
   *
   * This operation does not retry by default if the user has not defined a retry configuration.
   * @param ChangeHsmClusterCompartmentRequest
   * @return ChangeHsmClusterCompartmentResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/keymanagement/ChangeHsmClusterCompartment.ts.html |here} to see how to use ChangeHsmClusterCompartment API.
   */
  public async changeHsmClusterCompartment(
    changeHsmClusterCompartmentRequest: requests.ChangeHsmClusterCompartmentRequest
  ): Promise<responses.ChangeHsmClusterCompartmentResponse> {
    if (this.logger)
      this.logger.debug("Calling operation KmsHsmClusterClient#changeHsmClusterCompartment.");
    const operationName = "changeHsmClusterCompartment";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/key/release/HsmCluster/ChangeHsmClusterCompartment";
    const pathParams = {
      "{hsmClusterId}": changeHsmClusterCompartmentRequest.hsmClusterId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "if-match": changeHsmClusterCompartmentRequest.ifMatch,
      "opc-request-id": changeHsmClusterCompartmentRequest.opcRequestId,
      "opc-retry-token": changeHsmClusterCompartmentRequest.opcRetryToken
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      changeHsmClusterCompartmentRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/20180608/hsmClusters/{hsmClusterId}/actions/changeCompartment",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        changeHsmClusterCompartmentRequest.changeHsmClusterCompartmentDetails,
        "ChangeHsmClusterCompartmentDetails",
        model.ChangeHsmClusterCompartmentDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.ChangeHsmClusterCompartmentResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Creates a new HSM cluster resource.
   *
   * This operation does not retry by default if the user has not defined a retry configuration.
   * @param CreateHsmClusterRequest
   * @return CreateHsmClusterResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/keymanagement/CreateHsmCluster.ts.html |here} to see how to use CreateHsmCluster API.
   */
  public async createHsmCluster(
    createHsmClusterRequest: requests.CreateHsmClusterRequest
  ): Promise<responses.CreateHsmClusterResponse> {
    if (this.logger) this.logger.debug("Calling operation KmsHsmClusterClient#createHsmCluster.");
    const operationName = "createHsmCluster";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/key/release/HsmCluster/CreateHsmCluster";
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": createHsmClusterRequest.opcRequestId,
      "opc-retry-token": createHsmClusterRequest.opcRetryToken
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      createHsmClusterRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/20180608/hsmClusters",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createHsmClusterRequest.createHsmClusterDetails,
        "CreateHsmClusterDetails",
        model.CreateHsmClusterDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateHsmClusterResponse>{},
        body: await response.json(),
        bodyKey: "hsmCluster",
        bodyModel: model.HsmCluster,
        type: "model.HsmCluster",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Retrieves the certificate signing request for the designated HSM Cluster resource.
   *
   * This operation does not retry by default if the user has not defined a retry configuration.
   * @param DownloadCertificateSigningRequestRequest
   * @return DownloadCertificateSigningRequestResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/keymanagement/DownloadCertificateSigningRequest.ts.html |here} to see how to use DownloadCertificateSigningRequest API.
   */
  public async downloadCertificateSigningRequest(
    downloadCertificateSigningRequestRequest: requests.DownloadCertificateSigningRequestRequest
  ): Promise<responses.DownloadCertificateSigningRequestResponse> {
    if (this.logger)
      this.logger.debug("Calling operation KmsHsmClusterClient#downloadCertificateSigningRequest.");
    const operationName = "downloadCertificateSigningRequest";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/key/release/HsmCluster/DownloadCertificateSigningRequest";
    const pathParams = {
      "{hsmClusterId}": downloadCertificateSigningRequestRequest.hsmClusterId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": downloadCertificateSigningRequestRequest.opcRequestId,
      "opc-retry-token": downloadCertificateSigningRequestRequest.opcRetryToken,
      "if-match": downloadCertificateSigningRequestRequest.ifMatch
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      downloadCertificateSigningRequestRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/20180608/hsmClusters/{hsmClusterId}/actions/downloadCertificateSigningRequest",
      method: "POST",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.DownloadCertificateSigningRequestResponse>{},
        body: await response.json(),
        bodyKey: "value",
        bodyModel: "string",
        type: "string",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
     * Retrieves configuration details for the specified HSM Cluster resource.
* <p>
As a provisioning operation, this call is subject to a Key Management limit that applies to
* the total number of requests across all provisioning read operations. Key Management might
* throttle this call to reject an otherwise valid request when the total rate of provisioning
* read operations exceeds 10 requests per second for a given tenancy.
* 
     * This operation does not retry by default if the user has not defined a retry configuration.
     * @param GetHsmClusterRequest
     * @return GetHsmClusterResponse
     * @throws OciError when an error occurs
     * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/keymanagement/GetHsmCluster.ts.html |here} to see how to use GetHsmCluster API.
     */
  public async getHsmCluster(
    getHsmClusterRequest: requests.GetHsmClusterRequest
  ): Promise<responses.GetHsmClusterResponse> {
    if (this.logger) this.logger.debug("Calling operation KmsHsmClusterClient#getHsmCluster.");
    const operationName = "getHsmCluster";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/key/release/HsmCluster/GetHsmCluster";
    const pathParams = {
      "{hsmClusterId}": getHsmClusterRequest.hsmClusterId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": getHsmClusterRequest.opcRequestId
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      getHsmClusterRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/20180608/hsmClusters/{hsmClusterId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.GetHsmClusterResponse>{},
        body: await response.json(),
        bodyKey: "hsmCluster",
        bodyModel: model.HsmCluster,
        type: "model.HsmCluster",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Retrieves HSM partition details for the specified HSM cluster.
   *
   * This operation does not retry by default if the user has not defined a retry configuration.
   * @param GetHsmPartitionRequest
   * @return GetHsmPartitionResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/keymanagement/GetHsmPartition.ts.html |here} to see how to use GetHsmPartition API.
   */
  public async getHsmPartition(
    getHsmPartitionRequest: requests.GetHsmPartitionRequest
  ): Promise<responses.GetHsmPartitionResponse> {
    if (this.logger) this.logger.debug("Calling operation KmsHsmClusterClient#getHsmPartition.");
    const operationName = "getHsmPartition";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/key/release/HsmPartition/GetHsmPartition";
    const pathParams = {
      "{hsmClusterId}": getHsmPartitionRequest.hsmClusterId,
      "{hsmPartitionId}": getHsmPartitionRequest.hsmPartitionId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": getHsmPartitionRequest.opcRequestId,
      "opc-retry-token": getHsmPartitionRequest.opcRetryToken
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      getHsmPartitionRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/20180608/hsmClusters/{hsmClusterId}/hsmPartitions/{hsmPartitionId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.GetHsmPartitionResponse>{},
        body: await response.json(),
        bodyKey: "hsmPartition",
        bodyModel: model.HsmPartition,
        type: "model.HsmPartition",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Retrieves Pre Crypto Officer user credentials for the specified HSM cluster.
   *
   * This operation does not retry by default if the user has not defined a retry configuration.
   * @param GetPreCoUserCredentialsRequest
   * @return GetPreCoUserCredentialsResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/keymanagement/GetPreCoUserCredentials.ts.html |here} to see how to use GetPreCoUserCredentials API.
   */
  public async getPreCoUserCredentials(
    getPreCoUserCredentialsRequest: requests.GetPreCoUserCredentialsRequest
  ): Promise<responses.GetPreCoUserCredentialsResponse> {
    if (this.logger)
      this.logger.debug("Calling operation KmsHsmClusterClient#getPreCoUserCredentials.");
    const operationName = "getPreCoUserCredentials";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/key/release/HsmCluster/GetPreCoUserCredentials";
    const pathParams = {
      "{hsmClusterId}": getPreCoUserCredentialsRequest.hsmClusterId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": getPreCoUserCredentialsRequest.opcRequestId,
      "opc-retry-token": getPreCoUserCredentialsRequest.opcRetryToken
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      getPreCoUserCredentialsRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/20180608/hsmClusters/{hsmClusterId}/preCoUserCredentials",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.GetPreCoUserCredentialsResponse>{},
        body: await response.json(),
        bodyKey: "preCoUserCredentials",
        bodyModel: model.PreCoUserCredentials,
        type: "model.PreCoUserCredentials",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
     * Lists all HSM cluster resources contained within the specified compartment.
* <p>
As a provisioning operation, this call is subject to a Key Management limit that applies to
* the total number of requests across all provisioning read operations. Key Management might
* throttle this call to reject an otherwise valid request when the total rate of provisioning
* read operations exceeds 10 requests per second for a given tenancy.
* 
     * This operation does not retry by default if the user has not defined a retry configuration.
     * @param ListHsmClustersRequest
     * @return ListHsmClustersResponse
     * @throws OciError when an error occurs
     * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/keymanagement/ListHsmClusters.ts.html |here} to see how to use ListHsmClusters API.
     */
  public async listHsmClusters(
    listHsmClustersRequest: requests.ListHsmClustersRequest
  ): Promise<responses.ListHsmClustersResponse> {
    if (this.logger) this.logger.debug("Calling operation KmsHsmClusterClient#listHsmClusters.");
    const operationName = "listHsmClusters";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/key/release/HsmCluster/ListHsmClusters";
    const pathParams = {};

    const queryParams = {
      "compartmentId": listHsmClustersRequest.compartmentId,
      "limit": listHsmClustersRequest.limit,
      "page": listHsmClustersRequest.page,
      "sortBy": listHsmClustersRequest.sortBy,
      "sortOrder": listHsmClustersRequest.sortOrder
    };

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": listHsmClustersRequest.opcRequestId
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      listHsmClustersRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/20180608/hsmClusters",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.ListHsmClustersResponse>{},
        body: await response.json(),
        bodyKey: "hsmClusterCollection",
        bodyModel: model.HsmClusterCollection,
        type: "model.HsmClusterCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Lists all HSM partitions within the specified HSM Cluster resource.
   *
   * This operation does not retry by default if the user has not defined a retry configuration.
   * @param ListHsmPartitionsRequest
   * @return ListHsmPartitionsResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/keymanagement/ListHsmPartitions.ts.html |here} to see how to use ListHsmPartitions API.
   */
  public async listHsmPartitions(
    listHsmPartitionsRequest: requests.ListHsmPartitionsRequest
  ): Promise<responses.ListHsmPartitionsResponse> {
    if (this.logger) this.logger.debug("Calling operation KmsHsmClusterClient#listHsmPartitions.");
    const operationName = "listHsmPartitions";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/key/release/HsmPartition/ListHsmPartitions";
    const pathParams = {
      "{hsmClusterId}": listHsmPartitionsRequest.hsmClusterId
    };

    const queryParams = {
      "limit": listHsmPartitionsRequest.limit,
      "page": listHsmPartitionsRequest.page,
      "sortBy": listHsmPartitionsRequest.sortBy,
      "sortOrder": listHsmPartitionsRequest.sortOrder,
      "lifecycleState": listHsmPartitionsRequest.lifecycleState
    };

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": listHsmPartitionsRequest.opcRequestId
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      listHsmPartitionsRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/20180608/hsmClusters/{hsmClusterId}/hsmPartitions",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.ListHsmPartitionsResponse>{},
        body: await response.json(),
        bodyKey: "hsmPartitionCollection",
        bodyModel: model.HsmPartitionCollection,
        type: "model.HsmPartitionCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Schedules HSM cluster for deletion, update its lifecycle state to 'PENDING_DELETION'
   * and deletes it after the retention period.
   *
   * This operation does not retry by default if the user has not defined a retry configuration.
   * @param ScheduleHsmClusterDeletionRequest
   * @return ScheduleHsmClusterDeletionResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/keymanagement/ScheduleHsmClusterDeletion.ts.html |here} to see how to use ScheduleHsmClusterDeletion API.
   */
  public async scheduleHsmClusterDeletion(
    scheduleHsmClusterDeletionRequest: requests.ScheduleHsmClusterDeletionRequest
  ): Promise<responses.ScheduleHsmClusterDeletionResponse> {
    if (this.logger)
      this.logger.debug("Calling operation KmsHsmClusterClient#scheduleHsmClusterDeletion.");
    const operationName = "scheduleHsmClusterDeletion";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/key/release/HsmCluster/ScheduleHsmClusterDeletion";
    const pathParams = {
      "{hsmClusterId}": scheduleHsmClusterDeletionRequest.hsmClusterId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "if-match": scheduleHsmClusterDeletionRequest.ifMatch,
      "opc-request-id": scheduleHsmClusterDeletionRequest.opcRequestId,
      "opc-retry-token": scheduleHsmClusterDeletionRequest.opcRetryToken
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      scheduleHsmClusterDeletionRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/20180608/hsmClusters/{hsmClusterId}/actions/scheduleDeletion",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        scheduleHsmClusterDeletionRequest.scheduleHsmClusterDeletionDetails,
        "ScheduleHsmClusterDeletionDetails",
        model.ScheduleHsmClusterDeletionDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.ScheduleHsmClusterDeletionResponse>{},
        body: await response.json(),
        bodyKey: "hsmCluster",
        bodyModel: model.HsmCluster,
        type: "model.HsmCluster",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
     * Modifies properties of an HSM cluster resource, including `displayName`, `freeformTags` and `definedTags`.
* <p>
As a provisioning operation, this call is subject to a Key Management limit that applies to
* the total number of requests across all provisioning write operations. Key Management might
* throttle this call to reject an otherwise valid request when the total rate of provisioning
* write operations exceeds 10 requests per second for a given tenancy.
* 
     * This operation does not retry by default if the user has not defined a retry configuration.
     * @param UpdateHsmClusterRequest
     * @return UpdateHsmClusterResponse
     * @throws OciError when an error occurs
     * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/keymanagement/UpdateHsmCluster.ts.html |here} to see how to use UpdateHsmCluster API.
     */
  public async updateHsmCluster(
    updateHsmClusterRequest: requests.UpdateHsmClusterRequest
  ): Promise<responses.UpdateHsmClusterResponse> {
    if (this.logger) this.logger.debug("Calling operation KmsHsmClusterClient#updateHsmCluster.");
    const operationName = "updateHsmCluster";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/key/release/HsmCluster/UpdateHsmCluster";
    const pathParams = {
      "{hsmClusterId}": updateHsmClusterRequest.hsmClusterId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "if-match": updateHsmClusterRequest.ifMatch,
      "opc-request-id": updateHsmClusterRequest.opcRequestId
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      updateHsmClusterRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/20180608/hsmClusters/{hsmClusterId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateHsmClusterRequest.updateHsmClusterDetails,
        "UpdateHsmClusterDetails",
        model.UpdateHsmClusterDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateHsmClusterResponse>{},
        body: await response.json(),
        bodyKey: "hsmCluster",
        bodyModel: model.HsmCluster,
        type: "model.HsmCluster",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Uploads the partition owner certificates to the HSM Cluster resource.
   *
   * This operation does not retry by default if the user has not defined a retry configuration.
   * @param UploadPartitionCertificatesRequest
   * @return UploadPartitionCertificatesResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/keymanagement/UploadPartitionCertificates.ts.html |here} to see how to use UploadPartitionCertificates API.
   */
  public async uploadPartitionCertificates(
    uploadPartitionCertificatesRequest: requests.UploadPartitionCertificatesRequest
  ): Promise<responses.UploadPartitionCertificatesResponse> {
    if (this.logger)
      this.logger.debug("Calling operation KmsHsmClusterClient#uploadPartitionCertificates.");
    const operationName = "uploadPartitionCertificates";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/key/release/HsmCluster/UploadPartitionCertificates";
    const pathParams = {
      "{hsmClusterId}": uploadPartitionCertificatesRequest.hsmClusterId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": uploadPartitionCertificatesRequest.opcRequestId,
      "opc-retry-token": uploadPartitionCertificatesRequest.opcRetryToken,
      "if-match": uploadPartitionCertificatesRequest.ifMatch
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      uploadPartitionCertificatesRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/20180608/hsmClusters/{hsmClusterId}/actions/uploadPartitionCertificates",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        uploadPartitionCertificatesRequest.uploadPartitionCertificatesDetails,
        "UploadPartitionCertificatesDetails",
        model.UploadPartitionCertificatesDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.UploadPartitionCertificatesResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }
}
export enum KmsManagementApiKeys {}
/**
 * This service client uses {@link common.CircuitBreaker.DefaultConfiguration} for all the operations by default if no circuit breaker configuration is defined by the user.
 */
export class KmsManagementClient {
  protected static serviceEndpointTemplate = "https://kms.{region}.{secondLevelDomain}";
  protected static endpointServiceName = "";
  protected "_realmSpecificEndpointTemplateEnabled": boolean | undefined = undefined;
  protected "_endpoint": string = "";
  protected "_defaultHeaders": any = {};
  protected "_waiters": KmsManagementWaiter;
  protected "_clientConfiguration": common.ClientConfiguration;
  protected _circuitBreaker: typeof Breaker | null = null;
  protected _httpOptions: any = undefined;
  protected _bodyDuplexMode: any = undefined;
  public targetService = "KmsManagement";

  protected _httpClient: common.HttpClient;
  protected _authProvider: common.AuthenticationDetailsProvider | undefined;

  constructor(params: common.AuthParams, clientConfiguration?: common.ClientConfiguration) {
    const requestSigner = params.authenticationDetailsProvider
      ? new common.DefaultRequestSigner(params.authenticationDetailsProvider)
      : null;
    this._authProvider = params.authenticationDetailsProvider;
    if (clientConfiguration) {
      this._clientConfiguration = clientConfiguration;
      this._circuitBreaker = clientConfiguration.circuitBreaker
        ? clientConfiguration.circuitBreaker!.circuit
        : null;
      this._httpOptions = clientConfiguration.httpOptions
        ? clientConfiguration.httpOptions
        : undefined;
      this._bodyDuplexMode = clientConfiguration.bodyDuplexMode
        ? clientConfiguration.bodyDuplexMode
        : undefined;
    }

    if (!developerToolConfiguration.isServiceEnabled("keymanagement")) {
      let errmsg =
        "The developerToolConfiguration configuration disabled this service, this behavior is controlled by developerToolConfiguration.ociEnabledServiceSet variable. Please check if your local developer_tool_configuration file has configured the service you're targeting or contact the cloud provider on the availability of this service : ";
      throw errmsg.concat("keymanagement");
    }

    // if circuit breaker is not created, check if circuit breaker system is enabled to use default circuit breaker
    const specCircuitBreakerEnabled = true;
    if (
      !this._circuitBreaker &&
      common.utils.isCircuitBreakerSystemEnabled(clientConfiguration!) &&
      (specCircuitBreakerEnabled || common.CircuitBreaker.DefaultCircuitBreakerOverriden)
    ) {
      this._circuitBreaker = new common.CircuitBreaker().circuit;
    }
    this._httpClient =
      params.httpClient ||
      new common.FetchHttpClient(
        requestSigner,
        this._circuitBreaker,
        this._httpOptions,
        this._bodyDuplexMode
      );
  }

  /**
   * Get the endpoint that is being used to call (ex, https://www.example.com).
   */
  public get endpoint() {
    return this._endpoint;
  }

  /**
   * Sets the endpoint to call (ex, https://www.example.com).
   * @param endpoint The endpoint of the service.
   */
  public set endpoint(endpoint: string) {
    this._endpoint = endpoint;
    if (this.logger) this.logger.info(`KmsManagementClient endpoint set to ${this._endpoint}`);
  }

  public get logger() {
    return common.LOG.logger;
  }

  /**
   * Determines whether realm specific endpoint should be used or not.
   * Set realmSpecificEndpointTemplateEnabled to "true" if the user wants to enable use of realm specific endpoint template, otherwise set it to "false"
   * @param realmSpecificEndpointTemplateEnabled flag to enable the use of realm specific endpoint template
   */
  public set useRealmSpecificEndpointTemplate(realmSpecificEndpointTemplateEnabled: boolean) {
    this._realmSpecificEndpointTemplateEnabled = realmSpecificEndpointTemplateEnabled;
    if (this.logger)
      this.logger.info(
        `realmSpecificEndpointTemplateEnabled set to ${this._realmSpecificEndpointTemplateEnabled}`
      );
  }

  /**
   * Creates a new KmsManagementWaiter for resources for this service.
   *
   * @param config The waiter configuration for termination and delay strategy
   * @return The service waiters.
   */
  public createWaiters(config?: common.WaiterConfiguration): KmsManagementWaiter {
    this._waiters = new KmsManagementWaiter(this, config);
    return this._waiters;
  }

  /**
   * Gets the waiters available for resources for this service.
   *
   * @return The service waiters.
   */
  public getWaiters(): KmsManagementWaiter {
    if (this._waiters) {
      return this._waiters;
    }
    throw Error("Waiters do not exist. Please create waiters.");
  }

  /**
   * Shutdown the circuit breaker used by the client when it is no longer needed
   */
  public shutdownCircuitBreaker() {
    if (this._circuitBreaker) {
      this._circuitBreaker.shutdown();
    }
  }

  /**
   * Close the provider if possible which in turn shuts down any associated circuit breaker
   */
  public closeProvider() {
    if (this._authProvider) {
      if (this._authProvider instanceof common.AbstractRequestingAuthenticationDetailsProvider)
        (<common.AbstractRequestingAuthenticationDetailsProvider>(
          this._authProvider
        )).closeProvider();
    }
  }

  /**
   * Close the client once it is no longer needed
   */
  public close() {
    this.shutdownCircuitBreaker();
    this.closeProvider();
  }

  /**
   * Backs up an encrypted file that contains all key versions and metadata of the specified key so that you can restore
   * the key later. The file also contains the metadata of the vault that the key belonged to.
   *
   * This operation does not retry by default if the user has not defined a retry configuration.
   * @param BackupKeyRequest
   * @return BackupKeyResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/keymanagement/BackupKey.ts.html |here} to see how to use BackupKey API.
   */
  public async backupKey(
    backupKeyRequest: requests.BackupKeyRequest
  ): Promise<responses.BackupKeyResponse> {
    if (this.logger) this.logger.debug("Calling operation KmsManagementClient#backupKey.");
    const operationName = "backupKey";
    const apiReferenceLink = "https://docs.oracle.com/iaas/api/#/en/key/release/Key/BackupKey";
    const pathParams = {
      "{keyId}": backupKeyRequest.keyId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "if-match": backupKeyRequest.ifMatch,
      "opc-request-id": backupKeyRequest.opcRequestId,
      "opc-retry-token": backupKeyRequest.opcRetryToken
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      backupKeyRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/20180608/keys/{keyId}/actions/backup",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        backupKeyRequest.backupKeyDetails,
        "BackupKeyDetails",
        model.BackupKeyDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.BackupKeyResponse>{},
        body: await response.json(),
        bodyKey: "key",
        bodyModel: model.Key,
        type: "model.Key",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
     * Cancels the scheduled deletion of the specified key. Canceling
* a scheduled deletion restores the key's lifecycle state to what
* it was before its scheduled deletion.
* <p>
As a provisioning operation, this call is subject to a Key Management limit that applies to
* the total number of requests across all provisioning write operations. Key Management might
* throttle this call to reject an otherwise valid request when the total rate of provisioning
* write operations exceeds 10 requests per second for a given tenancy.
* 
     * This operation does not retry by default if the user has not defined a retry configuration.
     * @param CancelKeyDeletionRequest
     * @return CancelKeyDeletionResponse
     * @throws OciError when an error occurs
     * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/keymanagement/CancelKeyDeletion.ts.html |here} to see how to use CancelKeyDeletion API.
     */
  public async cancelKeyDeletion(
    cancelKeyDeletionRequest: requests.CancelKeyDeletionRequest
  ): Promise<responses.CancelKeyDeletionResponse> {
    if (this.logger) this.logger.debug("Calling operation KmsManagementClient#cancelKeyDeletion.");
    const operationName = "cancelKeyDeletion";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/key/release/Key/CancelKeyDeletion";
    const pathParams = {
      "{keyId}": cancelKeyDeletionRequest.keyId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "if-match": cancelKeyDeletionRequest.ifMatch,
      "opc-request-id": cancelKeyDeletionRequest.opcRequestId,
      "opc-retry-token": cancelKeyDeletionRequest.opcRetryToken
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      cancelKeyDeletionRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/20180608/keys/{keyId}/actions/cancelDeletion",
      method: "POST",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.CancelKeyDeletionResponse>{},
        body: await response.json(),
        bodyKey: "key",
        bodyModel: model.Key,
        type: "model.Key",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
     * Cancels the scheduled deletion of the specified key version. Canceling
* a scheduled deletion restores the key version to its lifecycle state from
* before its scheduled deletion.
* <p>
As a provisioning operation, this call is subject to a Key Management limit that applies to
* the total number of requests across all provisioning write operations. Key Management might
* throttle this call to reject an otherwise valid request when the total rate of provisioning
* write operations exceeds 10 requests per second for a given tenancy.
* 
     * This operation does not retry by default if the user has not defined a retry configuration.
     * @param CancelKeyVersionDeletionRequest
     * @return CancelKeyVersionDeletionResponse
     * @throws OciError when an error occurs
     * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/keymanagement/CancelKeyVersionDeletion.ts.html |here} to see how to use CancelKeyVersionDeletion API.
     */
  public async cancelKeyVersionDeletion(
    cancelKeyVersionDeletionRequest: requests.CancelKeyVersionDeletionRequest
  ): Promise<responses.CancelKeyVersionDeletionResponse> {
    if (this.logger)
      this.logger.debug("Calling operation KmsManagementClient#cancelKeyVersionDeletion.");
    const operationName = "cancelKeyVersionDeletion";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/key/release/KeyVersion/CancelKeyVersionDeletion";
    const pathParams = {
      "{keyId}": cancelKeyVersionDeletionRequest.keyId,
      "{keyVersionId}": cancelKeyVersionDeletionRequest.keyVersionId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "if-match": cancelKeyVersionDeletionRequest.ifMatch,
      "opc-request-id": cancelKeyVersionDeletionRequest.opcRequestId,
      "opc-retry-token": cancelKeyVersionDeletionRequest.opcRetryToken
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      cancelKeyVersionDeletionRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/20180608/keys/{keyId}/keyVersions/{keyVersionId}/actions/cancelDeletion",
      method: "POST",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.CancelKeyVersionDeletionResponse>{},
        body: await response.json(),
        bodyKey: "keyVersion",
        bodyModel: model.KeyVersion,
        type: "model.KeyVersion",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
     * Moves a key into a different compartment within the same tenancy. For information about
* moving resources between compartments, see [Moving Resources to a Different Compartment](https://docs.oracle.com/iaas/Content/Identity/Tasks/managingcompartments.htm#moveRes).
* <p>
When provided, if-match is checked against the ETag values of the key.
* <p>
As a provisioning operation, this call is subject to a Key Management limit that applies to
* the total number of requests across all provisioning write operations. Key Management might
* throttle this call to reject an otherwise valid request when the total rate of provisioning
* write operations exceeds 10 requests per second for a given tenancy.
* 
     * This operation does not retry by default if the user has not defined a retry configuration.
     * @param ChangeKeyCompartmentRequest
     * @return ChangeKeyCompartmentResponse
     * @throws OciError when an error occurs
     * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/keymanagement/ChangeKeyCompartment.ts.html |here} to see how to use ChangeKeyCompartment API.
     */
  public async changeKeyCompartment(
    changeKeyCompartmentRequest: requests.ChangeKeyCompartmentRequest
  ): Promise<responses.ChangeKeyCompartmentResponse> {
    if (this.logger)
      this.logger.debug("Calling operation KmsManagementClient#changeKeyCompartment.");
    const operationName = "changeKeyCompartment";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/key/release/Key/ChangeKeyCompartment";
    const pathParams = {
      "{keyId}": changeKeyCompartmentRequest.keyId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "if-match": changeKeyCompartmentRequest.ifMatch,
      "opc-request-id": changeKeyCompartmentRequest.opcRequestId,
      "opc-retry-token": changeKeyCompartmentRequest.opcRetryToken
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      changeKeyCompartmentRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/20180608/keys/{keyId}/actions/changeCompartment",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        changeKeyCompartmentRequest.changeKeyCompartmentDetails,
        "ChangeKeyCompartmentDetails",
        model.ChangeKeyCompartmentDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.ChangeKeyCompartmentResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
     * Creates a new master encryption key.
* <p>
As a management operation, this call is subject to a Key Management limit that applies to the total
* number of requests across all management write operations. Key Management might throttle this call
* to reject an otherwise valid request when the total rate of management write operations exceeds 10
* requests per second for a given tenancy.
* 
     * This operation does not retry by default if the user has not defined a retry configuration.
     * @param CreateKeyRequest
     * @return CreateKeyResponse
     * @throws OciError when an error occurs
     * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/keymanagement/CreateKey.ts.html |here} to see how to use CreateKey API.
     */
  public async createKey(
    createKeyRequest: requests.CreateKeyRequest
  ): Promise<responses.CreateKeyResponse> {
    if (this.logger) this.logger.debug("Calling operation KmsManagementClient#createKey.");
    const operationName = "createKey";
    const apiReferenceLink = "https://docs.oracle.com/iaas/api/#/en/key/release/Key/CreateKey";
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": createKeyRequest.opcRequestId,
      "opc-retry-token": createKeyRequest.opcRetryToken
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      createKeyRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/20180608/keys",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createKeyRequest.createKeyDetails,
        "CreateKeyDetails",
        model.CreateKeyDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateKeyResponse>{},
        body: await response.json(),
        bodyKey: "key",
        bodyModel: model.Key,
        type: "model.Key",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
     * Generates a new [KeyVersion](https://docs.oracle.com/iaas/api/#/en/key/latest/KeyVersion/) resource that provides new cryptographic
* material for a master encryption key. The key must be in an `ENABLED` state to be rotated.
* <p>
As a management operation, this call is subject to a Key Management limit that applies to the total number
* of requests across all  management write operations. Key Management might throttle this call to reject an
* otherwise valid request when the total rate of management write operations exceeds 10 requests per second
* for a given tenancy.
* 
     * This operation does not retry by default if the user has not defined a retry configuration.
     * @param CreateKeyVersionRequest
     * @return CreateKeyVersionResponse
     * @throws OciError when an error occurs
     * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/keymanagement/CreateKeyVersion.ts.html |here} to see how to use CreateKeyVersion API.
     */
  public async createKeyVersion(
    createKeyVersionRequest: requests.CreateKeyVersionRequest
  ): Promise<responses.CreateKeyVersionResponse> {
    if (this.logger) this.logger.debug("Calling operation KmsManagementClient#createKeyVersion.");
    const operationName = "createKeyVersion";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/key/release/KeyVersion/CreateKeyVersion";
    const pathParams = {
      "{keyId}": createKeyVersionRequest.keyId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": createKeyVersionRequest.opcRequestId,
      "opc-retry-token": createKeyVersionRequest.opcRetryToken
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      createKeyVersionRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/20180608/keys/{keyId}/keyVersions",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createKeyVersionRequest.createKeyMetadataDetails,
        "ExternalKeyVersionReference",
        model.ExternalKeyVersionReference.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateKeyVersionResponse>{},
        body: await response.json(),
        bodyKey: "keyVersion",
        bodyModel: model.KeyVersion,
        type: "model.KeyVersion",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
     * Disables a master encryption key so it can no longer be used for encryption, decryption, or
* generating new data encryption keys.
* <p>
As a management operation, this call is subject to a Key Management limit that applies to the total number
* of requests across all management write operations. Key Management might throttle this call to reject an
* otherwise valid request when the total rate of management write operations exceeds 10 requests per second
* for a given tenancy.
* 
     * This operation does not retry by default if the user has not defined a retry configuration.
     * @param DisableKeyRequest
     * @return DisableKeyResponse
     * @throws OciError when an error occurs
     * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/keymanagement/DisableKey.ts.html |here} to see how to use DisableKey API.
     */
  public async disableKey(
    disableKeyRequest: requests.DisableKeyRequest
  ): Promise<responses.DisableKeyResponse> {
    if (this.logger) this.logger.debug("Calling operation KmsManagementClient#disableKey.");
    const operationName = "disableKey";
    const apiReferenceLink = "https://docs.oracle.com/iaas/api/#/en/key/release/Key/DisableKey";
    const pathParams = {
      "{keyId}": disableKeyRequest.keyId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "if-match": disableKeyRequest.ifMatch,
      "opc-request-id": disableKeyRequest.opcRequestId,
      "opc-retry-token": disableKeyRequest.opcRetryToken
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      disableKeyRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/20180608/keys/{keyId}/actions/disable",
      method: "POST",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.DisableKeyResponse>{},
        body: await response.json(),
        bodyKey: "key",
        bodyModel: model.Key,
        type: "model.Key",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
     * Enables a master encryption key so it can be used for encryption, decryption, or
* generating new data encryption keys.
* <p>
As a management operation, this call is subject to a Key Management limit that applies to the total number
* of requests across all management write operations. Key Management might throttle this call to reject an
* otherwise valid request when the total rate of management write operations exceeds 10 requests per second
* for a given tenancy.
* 
     * This operation does not retry by default if the user has not defined a retry configuration.
     * @param EnableKeyRequest
     * @return EnableKeyResponse
     * @throws OciError when an error occurs
     * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/keymanagement/EnableKey.ts.html |here} to see how to use EnableKey API.
     */
  public async enableKey(
    enableKeyRequest: requests.EnableKeyRequest
  ): Promise<responses.EnableKeyResponse> {
    if (this.logger) this.logger.debug("Calling operation KmsManagementClient#enableKey.");
    const operationName = "enableKey";
    const apiReferenceLink = "https://docs.oracle.com/iaas/api/#/en/key/release/Key/EnableKey";
    const pathParams = {
      "{keyId}": enableKeyRequest.keyId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "if-match": enableKeyRequest.ifMatch,
      "opc-request-id": enableKeyRequest.opcRequestId,
      "opc-retry-token": enableKeyRequest.opcRetryToken
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      enableKeyRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/20180608/keys/{keyId}/actions/enable",
      method: "POST",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.EnableKeyResponse>{},
        body: await response.json(),
        bodyKey: "key",
        bodyModel: model.Key,
        type: "model.Key",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
     * Gets information about the specified master encryption key.
* <p>
As a management operation, this call is subject to a Key Management limit that applies to the total number
* of requests across all management read operations. Key Management might throttle this call to reject an
* otherwise valid request when the total rate of management read operations exceeds 10 requests per second for
* a given tenancy.
* 
     * This operation does not retry by default if the user has not defined a retry configuration.
     * @param GetKeyRequest
     * @return GetKeyResponse
     * @throws OciError when an error occurs
     * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/keymanagement/GetKey.ts.html |here} to see how to use GetKey API.
     */
  public async getKey(getKeyRequest: requests.GetKeyRequest): Promise<responses.GetKeyResponse> {
    if (this.logger) this.logger.debug("Calling operation KmsManagementClient#getKey.");
    const operationName = "getKey";
    const apiReferenceLink = "https://docs.oracle.com/iaas/api/#/en/key/release/Key/GetKey";
    const pathParams = {
      "{keyId}": getKeyRequest.keyId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": getKeyRequest.opcRequestId
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      getKeyRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/20180608/keys/{keyId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.GetKeyResponse>{},
        body: await response.json(),
        bodyKey: "key",
        bodyModel: model.Key,
        type: "model.Key",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
     * Gets information about the specified key version.
* <p>
As a management operation, this call is subject to a Key Management limit that applies to the total number
* of requests across all management read operations. Key Management might throttle this call to reject an
* otherwise valid request when the total rate of management read operations exceeds 10 requests per second
* for a given tenancy.
* 
     * This operation does not retry by default if the user has not defined a retry configuration.
     * @param GetKeyVersionRequest
     * @return GetKeyVersionResponse
     * @throws OciError when an error occurs
     * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/keymanagement/GetKeyVersion.ts.html |here} to see how to use GetKeyVersion API.
     */
  public async getKeyVersion(
    getKeyVersionRequest: requests.GetKeyVersionRequest
  ): Promise<responses.GetKeyVersionResponse> {
    if (this.logger) this.logger.debug("Calling operation KmsManagementClient#getKeyVersion.");
    const operationName = "getKeyVersion";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/key/release/KeyVersion/GetKeyVersion";
    const pathParams = {
      "{keyId}": getKeyVersionRequest.keyId,
      "{keyVersionId}": getKeyVersionRequest.keyVersionId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": getKeyVersionRequest.opcRequestId
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      getKeyVersionRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/20180608/keys/{keyId}/keyVersions/{keyVersionId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.GetKeyVersionResponse>{},
        body: await response.json(),
        bodyKey: "keyVersion",
        bodyModel: model.KeyVersion,
        type: "model.KeyVersion",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * When a vault has a replica, each operation on the vault or its resources, such as
   * keys, is replicated and has an associated replicationId. Replication status provides
   * details about whether the operation associated with the given replicationId has been
   * successfully applied across replicas.
   *
   * This operation does not retry by default if the user has not defined a retry configuration.
   * @param GetReplicationStatusRequest
   * @return GetReplicationStatusResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/keymanagement/GetReplicationStatus.ts.html |here} to see how to use GetReplicationStatus API.
   */
  public async getReplicationStatus(
    getReplicationStatusRequest: requests.GetReplicationStatusRequest
  ): Promise<responses.GetReplicationStatusResponse> {
    if (this.logger)
      this.logger.debug("Calling operation KmsManagementClient#getReplicationStatus.");
    const operationName = "getReplicationStatus";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/key/release/ReplicationStatusDetails/GetReplicationStatus";
    const pathParams = {
      "{replicationId}": getReplicationStatusRequest.replicationId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": getReplicationStatusRequest.opcRequestId
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      getReplicationStatusRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/20180608/replicaOperations/{replicationId}/status",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.GetReplicationStatusResponse>{},
        body: await response.json(),
        bodyKey: "replicationStatusDetails",
        bodyModel: model.ReplicationStatusDetails,
        type: "model.ReplicationStatusDetails",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Gets details about the public RSA wrapping key associated with the vault in the endpoint. Each vault has an RSA key-pair that wraps and
   * unwraps AES key material for import into Key Management.
   *
   * This operation does not retry by default if the user has not defined a retry configuration.
   * @param GetWrappingKeyRequest
   * @return GetWrappingKeyResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/keymanagement/GetWrappingKey.ts.html |here} to see how to use GetWrappingKey API.
   */
  public async getWrappingKey(
    getWrappingKeyRequest: requests.GetWrappingKeyRequest
  ): Promise<responses.GetWrappingKeyResponse> {
    if (this.logger) this.logger.debug("Calling operation KmsManagementClient#getWrappingKey.");
    const operationName = "getWrappingKey";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/key/release/WrappingKey/GetWrappingKey";
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": getWrappingKeyRequest.opcRequestId
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      getWrappingKeyRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/20180608/wrappingKeys",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.GetWrappingKeyResponse>{},
        body: await response.json(),
        bodyKey: "wrappingKey",
        bodyModel: model.WrappingKey,
        type: "model.WrappingKey",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Imports AES and RSA keys to create a new key. The key material must be base64-encoded
   * and wrapped by the vault's public RSA wrapping key before you can import it.
   * Key Management supports both RSA and AES keys. The AES keys are symmetric keys
   * of length 128 bits (16 bytes), 192 bits (24 bytes), or 256 bits (32 bytes), and the RSA keys are asymmetric keys of length 2048 bits (256 bytes), 3072 bits (384 bytes), and 4096 bits (512 bytes).
   * Furthermore, the key length must match what you specify at the time of import. When importing an asymmetric key,
   * only private key must be wrapped in PKCS8 format while the corresponding public key is generated internally by KMS.
   *
   * This operation does not retry by default if the user has not defined a retry configuration.
   * @param ImportKeyRequest
   * @return ImportKeyResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/keymanagement/ImportKey.ts.html |here} to see how to use ImportKey API.
   */
  public async importKey(
    importKeyRequest: requests.ImportKeyRequest
  ): Promise<responses.ImportKeyResponse> {
    if (this.logger) this.logger.debug("Calling operation KmsManagementClient#importKey.");
    const operationName = "importKey";
    const apiReferenceLink = "https://docs.oracle.com/iaas/api/#/en/key/release/Key/ImportKey";
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": importKeyRequest.opcRequestId,
      "opc-retry-token": importKeyRequest.opcRetryToken
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      importKeyRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/20180608/keys/import",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        importKeyRequest.importKeyDetails,
        "ImportKeyDetails",
        model.ImportKeyDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.ImportKeyResponse>{},
        body: await response.json(),
        bodyKey: "key",
        bodyModel: model.Key,
        type: "model.Key",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Imports AES key material to create a new key version and then rotate the key to begin using the new
   * key version. The key material must be base64-encoded and wrapped by the vault's public RSA wrapping key
   * before you can import it. Key Management supports AES symmetric keys that are exactly 16, 24, or 32 bytes.
   * Furthermore, the key length must match the length of the specified key and what you specify as the length
   * at the time of import. When importing an asymmetric key, only the private key must be wrapped in PKCS8 format
   * while the corresponding public key is generated internally by KMS.
   *
   * This operation does not retry by default if the user has not defined a retry configuration.
   * @param ImportKeyVersionRequest
   * @return ImportKeyVersionResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/keymanagement/ImportKeyVersion.ts.html |here} to see how to use ImportKeyVersion API.
   */
  public async importKeyVersion(
    importKeyVersionRequest: requests.ImportKeyVersionRequest
  ): Promise<responses.ImportKeyVersionResponse> {
    if (this.logger) this.logger.debug("Calling operation KmsManagementClient#importKeyVersion.");
    const operationName = "importKeyVersion";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/key/release/KeyVersion/ImportKeyVersion";
    const pathParams = {
      "{keyId}": importKeyVersionRequest.keyId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": importKeyVersionRequest.opcRequestId,
      "opc-retry-token": importKeyVersionRequest.opcRetryToken
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      importKeyVersionRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/20180608/keys/{keyId}/keyVersions/import",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        importKeyVersionRequest.importKeyVersionDetails,
        "ImportKeyVersionDetails",
        model.ImportKeyVersionDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.ImportKeyVersionResponse>{},
        body: await response.json(),
        bodyKey: "keyVersion",
        bodyModel: model.KeyVersion,
        type: "model.KeyVersion",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
     * Lists all [KeyVersion](https://docs.oracle.com/iaas/api/#/en/key/latest/KeyVersion/) resources for the specified
* master encryption key.
* <p>
As a management operation, this call is subject to a Key Management limit that applies to the total number
* of requests across all management read operations. Key Management might throttle this call to reject an
* otherwise valid request when the total rate of management read operations exceeds 10 requests per second
* for a given tenancy.
* 
     * This operation does not retry by default if the user has not defined a retry configuration.
     * @param ListKeyVersionsRequest
     * @return ListKeyVersionsResponse
     * @throws OciError when an error occurs
     * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/keymanagement/ListKeyVersions.ts.html |here} to see how to use ListKeyVersions API.
     */
  public async listKeyVersions(
    listKeyVersionsRequest: requests.ListKeyVersionsRequest
  ): Promise<responses.ListKeyVersionsResponse> {
    if (this.logger) this.logger.debug("Calling operation KmsManagementClient#listKeyVersions.");
    const operationName = "listKeyVersions";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/key/release/KeyVersionSummary/ListKeyVersions";
    const pathParams = {
      "{keyId}": listKeyVersionsRequest.keyId
    };

    const queryParams = {
      "limit": listKeyVersionsRequest.limit,
      "page": listKeyVersionsRequest.page,
      "sortBy": listKeyVersionsRequest.sortBy,
      "sortOrder": listKeyVersionsRequest.sortOrder
    };

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": listKeyVersionsRequest.opcRequestId
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      listKeyVersionsRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/20180608/keys/{keyId}/keyVersions",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.ListKeyVersionsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: model.KeyVersionSummary,
        type: "Array<model.KeyVersionSummary>",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * NOTE: This function is deprecated in favor of listKeyVersionsRecordIterator function.
   * Creates a new async iterator which will iterate over the models.KeyVersionSummary objects
   * contained in responses from the listKeyVersions operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllKeyVersions(
    request: requests.ListKeyVersionsRequest
  ): AsyncIterableIterator<model.KeyVersionSummary> {
    return paginateRecords(request, req => this.listKeyVersions(req));
  }

  /**
   * NOTE: This function is deprecated in favor of listKeyVersionsResponseIterator function.
   * Creates a new async iterator which will iterate over the responses received from the listKeyVersions operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllKeyVersionsResponses(
    request: requests.ListKeyVersionsRequest
  ): AsyncIterableIterator<responses.ListKeyVersionsResponse> {
    return paginateResponses(request, req => this.listKeyVersions(req));
  }

  /**
   * Creates a new async iterator which will iterate over the models.KeyVersionSummary objects
   * contained in responses from the listKeyVersions operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listKeyVersionsRecordIterator(
    request: requests.ListKeyVersionsRequest
  ): AsyncIterableIterator<model.KeyVersionSummary> {
    return paginateRecords(request, req => this.listKeyVersions(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listKeyVersions operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listKeyVersionsResponseIterator(
    request: requests.ListKeyVersionsRequest
  ): AsyncIterableIterator<responses.ListKeyVersionsResponse> {
    return paginateResponses(request, req => this.listKeyVersions(req));
  }

  /**
     * Lists the master encryption keys in the specified vault and compartment.
* <p>
As a management operation, this call is subject to a Key Management limit that applies to the total number
* of requests across all management read operations. Key Management might throttle this call to reject an
* otherwise valid request when the total rate of management read operations exceeds 10 requests per second
* for a given tenancy.
* 
     * This operation does not retry by default if the user has not defined a retry configuration.
     * @param ListKeysRequest
     * @return ListKeysResponse
     * @throws OciError when an error occurs
     * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/keymanagement/ListKeys.ts.html |here} to see how to use ListKeys API.
     */
  public async listKeys(
    listKeysRequest: requests.ListKeysRequest
  ): Promise<responses.ListKeysResponse> {
    if (this.logger) this.logger.debug("Calling operation KmsManagementClient#listKeys.");
    const operationName = "listKeys";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/key/release/KeySummary/ListKeys";
    const pathParams = {};

    const queryParams = {
      "compartmentId": listKeysRequest.compartmentId,
      "limit": listKeysRequest.limit,
      "page": listKeysRequest.page,
      "sortBy": listKeysRequest.sortBy,
      "sortOrder": listKeysRequest.sortOrder,
      "protectionMode": listKeysRequest.protectionMode,
      "algorithm": listKeysRequest.algorithm,
      "length": listKeysRequest.length,
      "curveId": listKeysRequest.curveId
    };

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": listKeysRequest.opcRequestId
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      listKeysRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/20180608/keys",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.ListKeysResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: model.KeySummary,
        type: "Array<model.KeySummary>",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * NOTE: This function is deprecated in favor of listKeysRecordIterator function.
   * Creates a new async iterator which will iterate over the models.KeySummary objects
   * contained in responses from the listKeys operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllKeys(request: requests.ListKeysRequest): AsyncIterableIterator<model.KeySummary> {
    return paginateRecords(request, req => this.listKeys(req));
  }

  /**
   * NOTE: This function is deprecated in favor of listKeysResponseIterator function.
   * Creates a new async iterator which will iterate over the responses received from the listKeys operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllKeysResponses(
    request: requests.ListKeysRequest
  ): AsyncIterableIterator<responses.ListKeysResponse> {
    return paginateResponses(request, req => this.listKeys(req));
  }

  /**
   * Creates a new async iterator which will iterate over the models.KeySummary objects
   * contained in responses from the listKeys operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listKeysRecordIterator(
    request: requests.ListKeysRequest
  ): AsyncIterableIterator<model.KeySummary> {
    return paginateRecords(request, req => this.listKeys(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listKeys operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listKeysResponseIterator(
    request: requests.ListKeysRequest
  ): AsyncIterableIterator<responses.ListKeysResponse> {
    return paginateResponses(request, req => this.listKeys(req));
  }

  /**
   * Restores the specified key to the specified vault, based on information in the backup file provided.
   * If the vault doesn't exist, the operation returns a response with a 404 HTTP status error code. You
   * need to first restore the vault associated with the key.
   *
   * This operation does not retry by default if the user has not defined a retry configuration.
   * @param RestoreKeyFromFileRequest
   * @return RestoreKeyFromFileResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/keymanagement/RestoreKeyFromFile.ts.html |here} to see how to use RestoreKeyFromFile API.
   */
  public async restoreKeyFromFile(
    restoreKeyFromFileRequest: requests.RestoreKeyFromFileRequest
  ): Promise<responses.RestoreKeyFromFileResponse> {
    if (this.logger) this.logger.debug("Calling operation KmsManagementClient#restoreKeyFromFile.");
    const operationName = "restoreKeyFromFile";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/key/release/Key/RestoreKeyFromFile";
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "content-length": restoreKeyFromFileRequest.contentLength,
      "if-match": restoreKeyFromFileRequest.ifMatch,
      "content-md5": restoreKeyFromFileRequest.contentMd5,
      "opc-request-id": restoreKeyFromFileRequest.opcRequestId,
      "opc-retry-token": restoreKeyFromFileRequest.opcRetryToken
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      restoreKeyFromFileRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/20180608/keys/actions/restoreFromFile",
      method: "POST",
      bodyContent: restoreKeyFromFileRequest.restoreKeyFromFileDetails,
      pathParams: pathParams,
      headerParams: headerParams,
      backupBinaryBody: retrier.backUpBinaryBody,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.RestoreKeyFromFileResponse>{},
        body: await response.json(),
        bodyKey: "key",
        bodyModel: model.Key,
        type: "model.Key",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-content-md5"),
            key: "opcContentMd5",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Restores the specified key to the specified vault from an Oracle Cloud Infrastructure
   * Object Storage location. If the vault doesn't exist, the operation returns a response with a
   * 404 HTTP status error code. You need to first restore the vault associated with the key.
   *
   * This operation does not retry by default if the user has not defined a retry configuration.
   * @param RestoreKeyFromObjectStoreRequest
   * @return RestoreKeyFromObjectStoreResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/keymanagement/RestoreKeyFromObjectStore.ts.html |here} to see how to use RestoreKeyFromObjectStore API.
   */
  public async restoreKeyFromObjectStore(
    restoreKeyFromObjectStoreRequest: requests.RestoreKeyFromObjectStoreRequest
  ): Promise<responses.RestoreKeyFromObjectStoreResponse> {
    if (this.logger)
      this.logger.debug("Calling operation KmsManagementClient#restoreKeyFromObjectStore.");
    const operationName = "restoreKeyFromObjectStore";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/key/release/Key/RestoreKeyFromObjectStore";
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "if-match": restoreKeyFromObjectStoreRequest.ifMatch,
      "opc-request-id": restoreKeyFromObjectStoreRequest.opcRequestId,
      "opc-retry-token": restoreKeyFromObjectStoreRequest.opcRetryToken
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      restoreKeyFromObjectStoreRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/20180608/keys/actions/restoreFromObjectStore",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        restoreKeyFromObjectStoreRequest.restoreKeyFromObjectStoreDetails,
        "RestoreKeyFromObjectStoreDetails",
        model.RestoreKeyFromObjectStoreDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.RestoreKeyFromObjectStoreResponse>{},
        body: await response.json(),
        bodyKey: "key",
        bodyModel: model.Key,
        type: "model.Key",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
     * Schedules the deletion of the specified key. This sets the lifecycle state of the key
* to `PENDING_DELETION` and then deletes it after the specified retention period ends.
* <p>
As a provisioning operation, this call is subject to a Key Management limit that applies to
* the total number of requests across all provisioning write operations. Key Management might
* throttle this call to reject an otherwise valid request when the total rate of provisioning
* write operations exceeds 10 requests per second for a given tenancy.
* 
     * This operation does not retry by default if the user has not defined a retry configuration.
     * @param ScheduleKeyDeletionRequest
     * @return ScheduleKeyDeletionResponse
     * @throws OciError when an error occurs
     * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/keymanagement/ScheduleKeyDeletion.ts.html |here} to see how to use ScheduleKeyDeletion API.
     */
  public async scheduleKeyDeletion(
    scheduleKeyDeletionRequest: requests.ScheduleKeyDeletionRequest
  ): Promise<responses.ScheduleKeyDeletionResponse> {
    if (this.logger)
      this.logger.debug("Calling operation KmsManagementClient#scheduleKeyDeletion.");
    const operationName = "scheduleKeyDeletion";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/key/release/Key/ScheduleKeyDeletion";
    const pathParams = {
      "{keyId}": scheduleKeyDeletionRequest.keyId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "if-match": scheduleKeyDeletionRequest.ifMatch,
      "opc-request-id": scheduleKeyDeletionRequest.opcRequestId,
      "opc-retry-token": scheduleKeyDeletionRequest.opcRetryToken
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      scheduleKeyDeletionRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/20180608/keys/{keyId}/actions/scheduleDeletion",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        scheduleKeyDeletionRequest.scheduleKeyDeletionDetails,
        "ScheduleKeyDeletionDetails",
        model.ScheduleKeyDeletionDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.ScheduleKeyDeletionResponse>{},
        body: await response.json(),
        bodyKey: "key",
        bodyModel: model.Key,
        type: "model.Key",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
     * Schedules the deletion of the specified key version. This sets the lifecycle state of the key version
* to `PENDING_DELETION` and then deletes it after the specified retention period ends.
* <p>
As a provisioning operation, this call is subject to a Key Management limit that applies to
* the total number of requests across all provisioning write operations. Key Management might
* throttle this call to reject an otherwise valid request when the total rate of provisioning
* write operations exceeds 10 requests per second for a given tenancy.
* 
     * This operation does not retry by default if the user has not defined a retry configuration.
     * @param ScheduleKeyVersionDeletionRequest
     * @return ScheduleKeyVersionDeletionResponse
     * @throws OciError when an error occurs
     * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/keymanagement/ScheduleKeyVersionDeletion.ts.html |here} to see how to use ScheduleKeyVersionDeletion API.
     */
  public async scheduleKeyVersionDeletion(
    scheduleKeyVersionDeletionRequest: requests.ScheduleKeyVersionDeletionRequest
  ): Promise<responses.ScheduleKeyVersionDeletionResponse> {
    if (this.logger)
      this.logger.debug("Calling operation KmsManagementClient#scheduleKeyVersionDeletion.");
    const operationName = "scheduleKeyVersionDeletion";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/key/release/KeyVersion/ScheduleKeyVersionDeletion";
    const pathParams = {
      "{keyId}": scheduleKeyVersionDeletionRequest.keyId,
      "{keyVersionId}": scheduleKeyVersionDeletionRequest.keyVersionId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "if-match": scheduleKeyVersionDeletionRequest.ifMatch,
      "opc-request-id": scheduleKeyVersionDeletionRequest.opcRequestId,
      "opc-retry-token": scheduleKeyVersionDeletionRequest.opcRetryToken
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      scheduleKeyVersionDeletionRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/20180608/keys/{keyId}/keyVersions/{keyVersionId}/actions/scheduleDeletion",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        scheduleKeyVersionDeletionRequest.scheduleKeyVersionDeletionDetails,
        "ScheduleKeyVersionDeletionDetails",
        model.ScheduleKeyVersionDeletionDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.ScheduleKeyVersionDeletionResponse>{},
        body: await response.json(),
        bodyKey: "keyVersion",
        bodyModel: model.KeyVersion,
        type: "model.KeyVersion",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
     * Updates the properties of a master encryption key. Specifically, you can update the
* `displayName`, `freeformTags`, and `definedTags` properties. Furthermore,
* the key must be in an `ENABLED` or `CREATING` state to be updated.
* <p>
As a management operation, this call is subject to a Key Management limit that applies to the total number
* of requests across all management write operations. Key Management might throttle this call to reject an
* otherwise valid request when the total rate of management write operations exceeds 10 requests per second
* for a given tenancy.
* 
     * This operation does not retry by default if the user has not defined a retry configuration.
     * @param UpdateKeyRequest
     * @return UpdateKeyResponse
     * @throws OciError when an error occurs
     * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/keymanagement/UpdateKey.ts.html |here} to see how to use UpdateKey API.
     */
  public async updateKey(
    updateKeyRequest: requests.UpdateKeyRequest
  ): Promise<responses.UpdateKeyResponse> {
    if (this.logger) this.logger.debug("Calling operation KmsManagementClient#updateKey.");
    const operationName = "updateKey";
    const apiReferenceLink = "https://docs.oracle.com/iaas/api/#/en/key/release/Key/UpdateKey";
    const pathParams = {
      "{keyId}": updateKeyRequest.keyId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "if-match": updateKeyRequest.ifMatch,
      "opc-request-id": updateKeyRequest.opcRequestId
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      updateKeyRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/20180608/keys/{keyId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateKeyRequest.updateKeyDetails,
        "UpdateKeyDetails",
        model.UpdateKeyDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateKeyResponse>{},
        body: await response.json(),
        bodyKey: "key",
        bodyModel: model.Key,
        type: "model.Key",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }
}
export enum KmsVaultApiKeys {}
/**
 * This service client uses {@link common.CircuitBreaker.DefaultConfiguration} for all the operations by default if no circuit breaker configuration is defined by the user.
 */
export class KmsVaultClient {
  protected static serviceEndpointTemplate = "https://kms.{region}.{secondLevelDomain}";
  protected static endpointServiceName = "";
  protected "_realmSpecificEndpointTemplateEnabled": boolean | undefined = undefined;
  protected "_endpoint": string = "";
  protected "_defaultHeaders": any = {};
  protected "_waiters": KmsVaultWaiter;
  protected "_clientConfiguration": common.ClientConfiguration;
  protected _circuitBreaker: typeof Breaker | null = null;
  protected _httpOptions: any = undefined;
  protected _bodyDuplexMode: any = undefined;
  public targetService = "KmsVault";
  protected _regionId: string = "";
  protected "_region": common.Region;
  protected _lastSetRegionOrRegionId: string = "";

  protected _httpClient: common.HttpClient;
  protected _authProvider: common.AuthenticationDetailsProvider | undefined;

  constructor(params: common.AuthParams, clientConfiguration?: common.ClientConfiguration) {
    const requestSigner = params.authenticationDetailsProvider
      ? new common.DefaultRequestSigner(params.authenticationDetailsProvider)
      : null;
    this._authProvider = params.authenticationDetailsProvider;
    if (clientConfiguration) {
      this._clientConfiguration = clientConfiguration;
      this._circuitBreaker = clientConfiguration.circuitBreaker
        ? clientConfiguration.circuitBreaker!.circuit
        : null;
      this._httpOptions = clientConfiguration.httpOptions
        ? clientConfiguration.httpOptions
        : undefined;
      this._bodyDuplexMode = clientConfiguration.bodyDuplexMode
        ? clientConfiguration.bodyDuplexMode
        : undefined;
    }

    if (!developerToolConfiguration.isServiceEnabled("keymanagement")) {
      let errmsg =
        "The developerToolConfiguration configuration disabled this service, this behavior is controlled by developerToolConfiguration.ociEnabledServiceSet variable. Please check if your local developer_tool_configuration file has configured the service you're targeting or contact the cloud provider on the availability of this service : ";
      throw errmsg.concat("keymanagement");
    }

    // if circuit breaker is not created, check if circuit breaker system is enabled to use default circuit breaker
    const specCircuitBreakerEnabled = true;
    if (
      !this._circuitBreaker &&
      common.utils.isCircuitBreakerSystemEnabled(clientConfiguration!) &&
      (specCircuitBreakerEnabled || common.CircuitBreaker.DefaultCircuitBreakerOverriden)
    ) {
      this._circuitBreaker = new common.CircuitBreaker().circuit;
    }
    this._httpClient =
      params.httpClient ||
      new common.FetchHttpClient(
        requestSigner,
        this._circuitBreaker,
        this._httpOptions,
        this._bodyDuplexMode
      );

    if (
      params.authenticationDetailsProvider &&
      common.isRegionProvider(params.authenticationDetailsProvider)
    ) {
      const provider: common.RegionProvider = params.authenticationDetailsProvider;
      if (provider.getRegion()) {
        this.region = provider.getRegion();
      }
    }
  }

  /**
   * Get the endpoint that is being used to call (ex, https://www.example.com).
   */
  public get endpoint() {
    return this._endpoint;
  }

  /**
   * Sets the endpoint to call (ex, https://www.example.com).
   * @param endpoint The endpoint of the service.
   */
  public set endpoint(endpoint: string) {
    this._endpoint = endpoint;
    if (this.logger) this.logger.info(`KmsVaultClient endpoint set to ${this._endpoint}`);
  }

  public get logger() {
    return common.LOG.logger;
  }

  /**
   * Determines whether realm specific endpoint should be used or not.
   * Set realmSpecificEndpointTemplateEnabled to "true" if the user wants to enable use of realm specific endpoint template, otherwise set it to "false"
   * @param realmSpecificEndpointTemplateEnabled flag to enable the use of realm specific endpoint template
   */
  public set useRealmSpecificEndpointTemplate(realmSpecificEndpointTemplateEnabled: boolean) {
    this._realmSpecificEndpointTemplateEnabled = realmSpecificEndpointTemplateEnabled;
    if (this.logger)
      this.logger.info(
        `realmSpecificEndpointTemplateEnabled set to ${this._realmSpecificEndpointTemplateEnabled}`
      );
    if (this._lastSetRegionOrRegionId === common.Region.REGION_STRING) {
      this.endpoint = common.EndpointBuilder.createEndpointFromRegion(
        KmsVaultClient.serviceEndpointTemplate,
        this._region,
        KmsVaultClient.endpointServiceName
      );
    } else if (this._lastSetRegionOrRegionId === common.Region.REGION_ID_STRING) {
      this.endpoint = common.EndpointBuilder.createEndpointFromRegionId(
        KmsVaultClient.serviceEndpointTemplate,
        this._regionId,
        KmsVaultClient.endpointServiceName
      );
    }
  }

  /**
   * Sets the region to call (ex, Region.US_PHOENIX_1).
   * Note, this will call {@link #endpoint(String) endpoint} after resolving the endpoint.
   * @param region The region of the service.
   */
  public set region(region: common.Region) {
    this._region = region;
    this.endpoint = common.EndpointBuilder.createEndpointFromRegion(
      KmsVaultClient.serviceEndpointTemplate,
      region,
      KmsVaultClient.endpointServiceName
    );
    this._lastSetRegionOrRegionId = common.Region.REGION_STRING;
  }

  /**
   * Sets the regionId to call (ex, 'us-phoenix-1').
   *
   * Note, this will first try to map the region ID to a known Region and call {@link #region(Region) region}.
   * If no known Region could be determined, it will create an endpoint assuming its in default Realm OC1
   * and then call {@link #endpoint(String) endpoint}.
   * @param regionId The public region ID.
   */
  public set regionId(regionId: string) {
    this._regionId = regionId;
    this.endpoint = common.EndpointBuilder.createEndpointFromRegionId(
      KmsVaultClient.serviceEndpointTemplate,
      regionId,
      KmsVaultClient.endpointServiceName
    );
    this._lastSetRegionOrRegionId = common.Region.REGION_ID_STRING;
  }

  /**
   * Creates a new KmsVaultWaiter for resources for this service.
   *
   * @param config The waiter configuration for termination and delay strategy
   * @return The service waiters.
   */
  public createWaiters(config?: common.WaiterConfiguration): KmsVaultWaiter {
    this._waiters = new KmsVaultWaiter(this, config);
    return this._waiters;
  }

  /**
   * Gets the waiters available for resources for this service.
   *
   * @return The service waiters.
   */
  public getWaiters(): KmsVaultWaiter {
    if (this._waiters) {
      return this._waiters;
    }
    throw Error("Waiters do not exist. Please create waiters.");
  }

  /**
   * Shutdown the circuit breaker used by the client when it is no longer needed
   */
  public shutdownCircuitBreaker() {
    if (this._circuitBreaker) {
      this._circuitBreaker.shutdown();
    }
  }

  /**
   * Close the provider if possible which in turn shuts down any associated circuit breaker
   */
  public closeProvider() {
    if (this._authProvider) {
      if (this._authProvider instanceof common.AbstractRequestingAuthenticationDetailsProvider)
        (<common.AbstractRequestingAuthenticationDetailsProvider>(
          this._authProvider
        )).closeProvider();
    }
  }

  /**
   * Close the client once it is no longer needed
   */
  public close() {
    this.shutdownCircuitBreaker();
    this.closeProvider();
  }

  /**
   * Backs up an encrypted file that contains all the metadata of a vault so that you can restore the vault later.
   * You can backup a vault whether or not it contains keys. This operation only backs up the
   * metadata of the vault, and does not include key metadata.
   *
   * This operation does not retry by default if the user has not defined a retry configuration.
   * @param BackupVaultRequest
   * @return BackupVaultResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/keymanagement/BackupVault.ts.html |here} to see how to use BackupVault API.
   */
  public async backupVault(
    backupVaultRequest: requests.BackupVaultRequest
  ): Promise<responses.BackupVaultResponse> {
    if (this.logger) this.logger.debug("Calling operation KmsVaultClient#backupVault.");
    const operationName = "backupVault";
    const apiReferenceLink = "https://docs.oracle.com/iaas/api/#/en/key/release/Vault/BackupVault";
    const pathParams = {
      "{vaultId}": backupVaultRequest.vaultId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "if-match": backupVaultRequest.ifMatch,
      "opc-request-id": backupVaultRequest.opcRequestId,
      "opc-retry-token": backupVaultRequest.opcRetryToken
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      backupVaultRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/20180608/vaults/{vaultId}/actions/backup",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        backupVaultRequest.backupVaultDetails,
        "BackupVaultDetails",
        model.BackupVaultDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.BackupVaultResponse>{},
        body: await response.json(),
        bodyKey: "vault",
        bodyModel: model.Vault,
        type: "model.Vault",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
     * Cancels the scheduled deletion of the specified vault. Canceling a scheduled deletion
* restores the vault and all keys in it to their respective states from before their
* scheduled deletion. All keys that were scheduled for deletion prior to vault
* deletion retain their lifecycle state and time of deletion.
* <p>
As a provisioning operation, this call is subject to a Key Management limit that applies to
* the total number of requests across all provisioning write operations. Key Management might
* throttle this call to reject an otherwise valid request when the total rate of provisioning
* write operations exceeds 10 requests per second for a given tenancy.
* 
     * This operation does not retry by default if the user has not defined a retry configuration.
     * @param CancelVaultDeletionRequest
     * @return CancelVaultDeletionResponse
     * @throws OciError when an error occurs
     * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/keymanagement/CancelVaultDeletion.ts.html |here} to see how to use CancelVaultDeletion API.
     */
  public async cancelVaultDeletion(
    cancelVaultDeletionRequest: requests.CancelVaultDeletionRequest
  ): Promise<responses.CancelVaultDeletionResponse> {
    if (this.logger) this.logger.debug("Calling operation KmsVaultClient#cancelVaultDeletion.");
    const operationName = "cancelVaultDeletion";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/key/release/Vault/CancelVaultDeletion";
    const pathParams = {
      "{vaultId}": cancelVaultDeletionRequest.vaultId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "if-match": cancelVaultDeletionRequest.ifMatch,
      "opc-request-id": cancelVaultDeletionRequest.opcRequestId,
      "opc-retry-token": cancelVaultDeletionRequest.opcRetryToken
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      cancelVaultDeletionRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/20180608/vaults/{vaultId}/actions/cancelDeletion",
      method: "POST",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.CancelVaultDeletionResponse>{},
        body: await response.json(),
        bodyKey: "vault",
        bodyModel: model.Vault,
        type: "model.Vault",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
     * Moves a vault into a different compartment within the same tenancy. For information about
* moving resources between compartments, see [Moving Resources to a Different Compartment](https://docs.oracle.com/iaas/Content/Identity/Tasks/managingcompartments.htm#moveRes).
* <p>
When provided, if-match is checked against the ETag values of the resource.
* <p>
As a provisioning operation, this call is subject to a Key Management limit that applies to
* the total number of requests across all provisioning write operations. Key Management might
* throttle this call to reject an otherwise valid request when the total rate of provisioning
* write operations exceeds 10 requests per second for a given tenancy.
* 
     * This operation does not retry by default if the user has not defined a retry configuration.
     * @param ChangeVaultCompartmentRequest
     * @return ChangeVaultCompartmentResponse
     * @throws OciError when an error occurs
     * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/keymanagement/ChangeVaultCompartment.ts.html |here} to see how to use ChangeVaultCompartment API.
     */
  public async changeVaultCompartment(
    changeVaultCompartmentRequest: requests.ChangeVaultCompartmentRequest
  ): Promise<responses.ChangeVaultCompartmentResponse> {
    if (this.logger) this.logger.debug("Calling operation KmsVaultClient#changeVaultCompartment.");
    const operationName = "changeVaultCompartment";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/key/release/Vault/ChangeVaultCompartment";
    const pathParams = {
      "{vaultId}": changeVaultCompartmentRequest.vaultId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "if-match": changeVaultCompartmentRequest.ifMatch,
      "opc-request-id": changeVaultCompartmentRequest.opcRequestId,
      "opc-retry-token": changeVaultCompartmentRequest.opcRetryToken
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      changeVaultCompartmentRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/20180608/vaults/{vaultId}/actions/changeCompartment",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        changeVaultCompartmentRequest.changeVaultCompartmentDetails,
        "ChangeVaultCompartmentDetails",
        model.ChangeVaultCompartmentDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.ChangeVaultCompartmentResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
     * Creates a new vault. The type of vault you create determines key placement, pricing, and
* available options. Options include storage isolation, a dedicated service endpoint instead
* of a shared service endpoint for API calls, and either a dedicated hardware security module
* (HSM) or a multitenant HSM.
* <p>
As a provisioning operation, this call is subject to a Key Management limit that applies to
* the total number of requests across all provisioning write operations. Key Management might
* throttle this call to reject an otherwise valid request when the total rate of provisioning
* write operations exceeds 10 requests per second for a given tenancy.
* 
     * This operation does not retry by default if the user has not defined a retry configuration.
     * @param CreateVaultRequest
     * @return CreateVaultResponse
     * @throws OciError when an error occurs
     * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/keymanagement/CreateVault.ts.html |here} to see how to use CreateVault API.
     */
  public async createVault(
    createVaultRequest: requests.CreateVaultRequest
  ): Promise<responses.CreateVaultResponse> {
    if (this.logger) this.logger.debug("Calling operation KmsVaultClient#createVault.");
    const operationName = "createVault";
    const apiReferenceLink = "https://docs.oracle.com/iaas/api/#/en/key/release/Vault/CreateVault";
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": createVaultRequest.opcRequestId,
      "opc-retry-token": createVaultRequest.opcRetryToken
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      createVaultRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/20180608/vaults",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createVaultRequest.createVaultDetails,
        "CreateVaultDetails",
        model.CreateVaultDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateVaultResponse>{},
        body: await response.json(),
        bodyKey: "vault",
        bodyModel: model.Vault,
        type: "model.Vault",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
     * Creates a replica for the vault in another region in the same realm
* <p>
The API is a no-op if called for same region that a vault is already replicated to.
* 409 if called on a vault that is already replicated to a different region. Users need to delete
* existing replica first before calling it with a different region.
* <p>
As a provisioning operation, this call is subject to a Key Management limit that applies to
* the total number of requests across all provisioning write operations. Key Management might
* throttle this call to reject an otherwise valid request when the total rate of provisioning
* write operations exceeds 10 requests per second for a given tenancy.
* 
     * This operation does not retry by default if the user has not defined a retry configuration.
     * @param CreateVaultReplicaRequest
     * @return CreateVaultReplicaResponse
     * @throws OciError when an error occurs
     * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/keymanagement/CreateVaultReplica.ts.html |here} to see how to use CreateVaultReplica API.
     */
  public async createVaultReplica(
    createVaultReplicaRequest: requests.CreateVaultReplicaRequest
  ): Promise<responses.CreateVaultReplicaResponse> {
    if (this.logger) this.logger.debug("Calling operation KmsVaultClient#createVaultReplica.");
    const operationName = "createVaultReplica";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/key/release/Vault/CreateVaultReplica";
    const pathParams = {
      "{vaultId}": createVaultReplicaRequest.vaultId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "if-match": createVaultReplicaRequest.ifMatch,
      "opc-request-id": createVaultReplicaRequest.opcRequestId,
      "opc-retry-token": createVaultReplicaRequest.opcRetryToken
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      createVaultReplicaRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/20180608/vaults/{vaultId}/actions/createReplica",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createVaultReplicaRequest.createVaultReplicaDetails,
        "CreateVaultReplicaDetails",
        model.CreateVaultReplicaDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateVaultReplicaResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
     * Deletes a vault replica
* <p>
As a provisioning operation, this call is subject to a Key Management limit that applies to
* the total number of requests across all provisioning write operations. Key Management might
* throttle this call to reject an otherwise valid request when the total rate of provisioning
* write operations exceeds 10 requests per second for a given tenancy.
* 
     * This operation does not retry by default if the user has not defined a retry configuration.
     * @param DeleteVaultReplicaRequest
     * @return DeleteVaultReplicaResponse
     * @throws OciError when an error occurs
     * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/keymanagement/DeleteVaultReplica.ts.html |here} to see how to use DeleteVaultReplica API.
     */
  public async deleteVaultReplica(
    deleteVaultReplicaRequest: requests.DeleteVaultReplicaRequest
  ): Promise<responses.DeleteVaultReplicaResponse> {
    if (this.logger) this.logger.debug("Calling operation KmsVaultClient#deleteVaultReplica.");
    const operationName = "deleteVaultReplica";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/key/release/Vault/DeleteVaultReplica";
    const pathParams = {
      "{vaultId}": deleteVaultReplicaRequest.vaultId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "if-match": deleteVaultReplicaRequest.ifMatch,
      "opc-request-id": deleteVaultReplicaRequest.opcRequestId,
      "opc-retry-token": deleteVaultReplicaRequest.opcRetryToken
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      deleteVaultReplicaRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/20180608/vaults/{vaultId}/actions/deleteReplica",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        deleteVaultReplicaRequest.deleteVaultReplicaDetails,
        "DeleteVaultReplicaDetails",
        model.DeleteVaultReplicaDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteVaultReplicaResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
     * Gets the specified vault's configuration information.
* <p>
As a provisioning operation, this call is subject to a Key Management limit that applies to
* the total number of requests across all provisioning read operations. Key Management might
* throttle this call to reject an otherwise valid request when the total rate of provisioning
* read operations exceeds 10 requests per second for a given tenancy.
* 
     * This operation does not retry by default if the user has not defined a retry configuration.
     * @param GetVaultRequest
     * @return GetVaultResponse
     * @throws OciError when an error occurs
     * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/keymanagement/GetVault.ts.html |here} to see how to use GetVault API.
     */
  public async getVault(
    getVaultRequest: requests.GetVaultRequest
  ): Promise<responses.GetVaultResponse> {
    if (this.logger) this.logger.debug("Calling operation KmsVaultClient#getVault.");
    const operationName = "getVault";
    const apiReferenceLink = "https://docs.oracle.com/iaas/api/#/en/key/release/Vault/GetVault";
    const pathParams = {
      "{vaultId}": getVaultRequest.vaultId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": getVaultRequest.opcRequestId
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      getVaultRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/20180608/vaults/{vaultId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.GetVaultResponse>{},
        body: await response.json(),
        bodyKey: "vault",
        bodyModel: model.Vault,
        type: "model.Vault",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Gets the count of keys and key versions in the specified vault to calculate usage against service limits.
   *
   * This operation does not retry by default if the user has not defined a retry configuration.
   * @param GetVaultUsageRequest
   * @return GetVaultUsageResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/keymanagement/GetVaultUsage.ts.html |here} to see how to use GetVaultUsage API.
   */
  public async getVaultUsage(
    getVaultUsageRequest: requests.GetVaultUsageRequest
  ): Promise<responses.GetVaultUsageResponse> {
    if (this.logger) this.logger.debug("Calling operation KmsVaultClient#getVaultUsage.");
    const operationName = "getVaultUsage";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/key/release/VaultUsage/GetVaultUsage";
    const pathParams = {
      "{vaultId}": getVaultUsageRequest.vaultId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": getVaultUsageRequest.opcRequestId
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      getVaultUsageRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/20180608/vaults/{vaultId}/usage",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.GetVaultUsageResponse>{},
        body: await response.json(),
        bodyKey: "vaultUsage",
        bodyModel: model.VaultUsage,
        type: "model.VaultUsage",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
     * Lists the replicas for a vault
* <p>
As a provisioning operation, this call is subject to a Key Management limit that applies to
* the total number of requests across all provisioning write operations. Key Management might
* throttle this call to reject an otherwise valid request when the total rate of provisioning
* write operations exceeds 10 requests per second for a given tenancy.
* 
     * This operation does not retry by default if the user has not defined a retry configuration.
     * @param ListVaultReplicasRequest
     * @return ListVaultReplicasResponse
     * @throws OciError when an error occurs
     * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/keymanagement/ListVaultReplicas.ts.html |here} to see how to use ListVaultReplicas API.
     */
  public async listVaultReplicas(
    listVaultReplicasRequest: requests.ListVaultReplicasRequest
  ): Promise<responses.ListVaultReplicasResponse> {
    if (this.logger) this.logger.debug("Calling operation KmsVaultClient#listVaultReplicas.");
    const operationName = "listVaultReplicas";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/key/release/Vault/ListVaultReplicas";
    const pathParams = {
      "{vaultId}": listVaultReplicasRequest.vaultId
    };

    const queryParams = {
      "limit": listVaultReplicasRequest.limit,
      "page": listVaultReplicasRequest.page,
      "sortBy": listVaultReplicasRequest.sortBy,
      "sortOrder": listVaultReplicasRequest.sortOrder
    };

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "if-match": listVaultReplicasRequest.ifMatch,
      "opc-request-id": listVaultReplicasRequest.opcRequestId,
      "opc-retry-token": listVaultReplicasRequest.opcRetryToken
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      listVaultReplicasRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/20180608/vaults/{vaultId}/actions/listReplicas",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.ListVaultReplicasResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: model.VaultReplicaSummary,
        type: "Array<model.VaultReplicaSummary>",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * NOTE: This function is deprecated in favor of listVaultReplicasRecordIterator function.
   * Creates a new async iterator which will iterate over the models.VaultReplicaSummary objects
   * contained in responses from the listVaultReplicas operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllVaultReplicas(
    request: requests.ListVaultReplicasRequest
  ): AsyncIterableIterator<model.VaultReplicaSummary> {
    return paginateRecords(request, req => this.listVaultReplicas(req));
  }

  /**
   * NOTE: This function is deprecated in favor of listVaultReplicasResponseIterator function.
   * Creates a new async iterator which will iterate over the responses received from the listVaultReplicas operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllVaultReplicasResponses(
    request: requests.ListVaultReplicasRequest
  ): AsyncIterableIterator<responses.ListVaultReplicasResponse> {
    return paginateResponses(request, req => this.listVaultReplicas(req));
  }

  /**
   * Creates a new async iterator which will iterate over the models.VaultReplicaSummary objects
   * contained in responses from the listVaultReplicas operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listVaultReplicasRecordIterator(
    request: requests.ListVaultReplicasRequest
  ): AsyncIterableIterator<model.VaultReplicaSummary> {
    return paginateRecords(request, req => this.listVaultReplicas(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listVaultReplicas operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listVaultReplicasResponseIterator(
    request: requests.ListVaultReplicasRequest
  ): AsyncIterableIterator<responses.ListVaultReplicasResponse> {
    return paginateResponses(request, req => this.listVaultReplicas(req));
  }

  /**
     * Lists the vaults in the specified compartment.
* <p>
As a provisioning operation, this call is subject to a Key Management limit that applies to
* the total number of requests across all provisioning read operations. Key Management might
* throttle this call to reject an otherwise valid request when the total rate of provisioning
* read operations exceeds 10 requests per second for a given tenancy.
* 
     * This operation does not retry by default if the user has not defined a retry configuration.
     * @param ListVaultsRequest
     * @return ListVaultsResponse
     * @throws OciError when an error occurs
     * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/keymanagement/ListVaults.ts.html |here} to see how to use ListVaults API.
     */
  public async listVaults(
    listVaultsRequest: requests.ListVaultsRequest
  ): Promise<responses.ListVaultsResponse> {
    if (this.logger) this.logger.debug("Calling operation KmsVaultClient#listVaults.");
    const operationName = "listVaults";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/key/release/VaultSummary/ListVaults";
    const pathParams = {};

    const queryParams = {
      "compartmentId": listVaultsRequest.compartmentId,
      "limit": listVaultsRequest.limit,
      "page": listVaultsRequest.page,
      "sortBy": listVaultsRequest.sortBy,
      "sortOrder": listVaultsRequest.sortOrder
    };

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": listVaultsRequest.opcRequestId
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      listVaultsRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/20180608/vaults",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.ListVaultsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: model.VaultSummary,
        type: "Array<model.VaultSummary>",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * NOTE: This function is deprecated in favor of listVaultsRecordIterator function.
   * Creates a new async iterator which will iterate over the models.VaultSummary objects
   * contained in responses from the listVaults operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllVaults(
    request: requests.ListVaultsRequest
  ): AsyncIterableIterator<model.VaultSummary> {
    return paginateRecords(request, req => this.listVaults(req));
  }

  /**
   * NOTE: This function is deprecated in favor of listVaultsResponseIterator function.
   * Creates a new async iterator which will iterate over the responses received from the listVaults operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllVaultsResponses(
    request: requests.ListVaultsRequest
  ): AsyncIterableIterator<responses.ListVaultsResponse> {
    return paginateResponses(request, req => this.listVaults(req));
  }

  /**
   * Creates a new async iterator which will iterate over the models.VaultSummary objects
   * contained in responses from the listVaults operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listVaultsRecordIterator(
    request: requests.ListVaultsRequest
  ): AsyncIterableIterator<model.VaultSummary> {
    return paginateRecords(request, req => this.listVaults(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listVaults operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listVaultsResponseIterator(
    request: requests.ListVaultsRequest
  ): AsyncIterableIterator<responses.ListVaultsResponse> {
    return paginateResponses(request, req => this.listVaults(req));
  }

  /**
   * Restores a vault from an encrypted backup file. If a vault
   * with the same OCID already exists, this operation returns a response with a
   * 409 HTTP status error code.
   *
   * This operation does not retry by default if the user has not defined a retry configuration.
   * @param RestoreVaultFromFileRequest
   * @return RestoreVaultFromFileResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/keymanagement/RestoreVaultFromFile.ts.html |here} to see how to use RestoreVaultFromFile API.
   */
  public async restoreVaultFromFile(
    restoreVaultFromFileRequest: requests.RestoreVaultFromFileRequest
  ): Promise<responses.RestoreVaultFromFileResponse> {
    if (this.logger) this.logger.debug("Calling operation KmsVaultClient#restoreVaultFromFile.");
    const operationName = "restoreVaultFromFile";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/key/release/Vault/RestoreVaultFromFile";
    const pathParams = {};

    const queryParams = {
      "compartmentId": restoreVaultFromFileRequest.compartmentId
    };

    let headerParams = {
      "content-length": restoreVaultFromFileRequest.contentLength,
      "if-match": restoreVaultFromFileRequest.ifMatch,
      "content-md5": restoreVaultFromFileRequest.contentMd5,
      "opc-request-id": restoreVaultFromFileRequest.opcRequestId,
      "opc-retry-token": restoreVaultFromFileRequest.opcRetryToken
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      restoreVaultFromFileRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/20180608/vaults/actions/restoreFromFile",
      method: "POST",
      bodyContent: restoreVaultFromFileRequest.restoreVaultFromFileDetails,
      pathParams: pathParams,
      headerParams: headerParams,
      backupBinaryBody: retrier.backUpBinaryBody,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.RestoreVaultFromFileResponse>{},
        body: await response.json(),
        bodyKey: "vault",
        bodyModel: model.Vault,
        type: "model.Vault",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-content-md5"),
            key: "opcContentMd5",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Restores a vault from an encrypted backup file stored in Oracle Cloud Infrastructure Object
   * Storage. If a vault with the same OCID already exists, this operation returns
   * a response with a 409 HTTP status error code.
   *
   * This operation does not retry by default if the user has not defined a retry configuration.
   * @param RestoreVaultFromObjectStoreRequest
   * @return RestoreVaultFromObjectStoreResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/keymanagement/RestoreVaultFromObjectStore.ts.html |here} to see how to use RestoreVaultFromObjectStore API.
   */
  public async restoreVaultFromObjectStore(
    restoreVaultFromObjectStoreRequest: requests.RestoreVaultFromObjectStoreRequest
  ): Promise<responses.RestoreVaultFromObjectStoreResponse> {
    if (this.logger)
      this.logger.debug("Calling operation KmsVaultClient#restoreVaultFromObjectStore.");
    const operationName = "restoreVaultFromObjectStore";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/key/release/Vault/RestoreVaultFromObjectStore";
    const pathParams = {};

    const queryParams = {
      "compartmentId": restoreVaultFromObjectStoreRequest.compartmentId
    };

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "if-match": restoreVaultFromObjectStoreRequest.ifMatch,
      "opc-request-id": restoreVaultFromObjectStoreRequest.opcRequestId,
      "opc-retry-token": restoreVaultFromObjectStoreRequest.opcRetryToken
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      restoreVaultFromObjectStoreRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/20180608/vaults/actions/restoreFromObjectStore",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        restoreVaultFromObjectStoreRequest.restoreVaultFromObjectStoreDetails,
        "RestoreVaultFromObjectStoreDetails",
        model.RestoreVaultFromObjectStoreDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.RestoreVaultFromObjectStoreResponse>{},
        body: await response.json(),
        bodyKey: "vault",
        bodyModel: model.Vault,
        type: "model.Vault",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
     * Schedules the deletion of the specified vault. This sets the lifecycle state of the vault and all keys in it
* that are not already scheduled for deletion to `PENDING_DELETION` and then deletes them after the
* retention period ends. The lifecycle state and time of deletion for keys already scheduled for deletion won't
* change. If any keys in the vault are scheduled to be deleted after the specified time of
* deletion for the vault, the call is rejected with the error code 409.
* <p>
As a provisioning operation, this call is subject to a Key Management limit that applies to
* the total number of requests across all provisioning write operations. Key Management might
* throttle this call to reject an otherwise valid request when the total rate of provisioning
* write operations exceeds 10 requests per second for a given tenancy.
* 
     * This operation does not retry by default if the user has not defined a retry configuration.
     * @param ScheduleVaultDeletionRequest
     * @return ScheduleVaultDeletionResponse
     * @throws OciError when an error occurs
     * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/keymanagement/ScheduleVaultDeletion.ts.html |here} to see how to use ScheduleVaultDeletion API.
     */
  public async scheduleVaultDeletion(
    scheduleVaultDeletionRequest: requests.ScheduleVaultDeletionRequest
  ): Promise<responses.ScheduleVaultDeletionResponse> {
    if (this.logger) this.logger.debug("Calling operation KmsVaultClient#scheduleVaultDeletion.");
    const operationName = "scheduleVaultDeletion";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/key/release/Vault/ScheduleVaultDeletion";
    const pathParams = {
      "{vaultId}": scheduleVaultDeletionRequest.vaultId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "if-match": scheduleVaultDeletionRequest.ifMatch,
      "opc-request-id": scheduleVaultDeletionRequest.opcRequestId,
      "opc-retry-token": scheduleVaultDeletionRequest.opcRetryToken
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      scheduleVaultDeletionRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/20180608/vaults/{vaultId}/actions/scheduleDeletion",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        scheduleVaultDeletionRequest.scheduleVaultDeletionDetails,
        "ScheduleVaultDeletionDetails",
        model.ScheduleVaultDeletionDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.ScheduleVaultDeletionResponse>{},
        body: await response.json(),
        bodyKey: "vault",
        bodyModel: model.Vault,
        type: "model.Vault",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
     * Updates the properties of a vault. Specifically, you can update the
* `displayName`, `freeformTags`, and `definedTags` properties. Furthermore,
* the vault must be in an ACTIVE or CREATING state to be updated.
* <p>
As a provisioning operation, this call is subject to a Key Management limit that applies to
* the total number of requests across all provisioning write operations. Key Management might
* throttle this call to reject an otherwise valid request when the total rate of provisioning
* write operations exceeds 10 requests per second for a given tenancy.
* 
     * This operation does not retry by default if the user has not defined a retry configuration.
     * @param UpdateVaultRequest
     * @return UpdateVaultResponse
     * @throws OciError when an error occurs
     * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/keymanagement/UpdateVault.ts.html |here} to see how to use UpdateVault API.
     */
  public async updateVault(
    updateVaultRequest: requests.UpdateVaultRequest
  ): Promise<responses.UpdateVaultResponse> {
    if (this.logger) this.logger.debug("Calling operation KmsVaultClient#updateVault.");
    const operationName = "updateVault";
    const apiReferenceLink = "https://docs.oracle.com/iaas/api/#/en/key/release/Vault/UpdateVault";
    const pathParams = {
      "{vaultId}": updateVaultRequest.vaultId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "if-match": updateVaultRequest.ifMatch,
      "opc-request-id": updateVaultRequest.opcRequestId
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      updateVaultRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/20180608/vaults/{vaultId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateVaultRequest.updateVaultDetails,
        "UpdateVaultDetails",
        model.UpdateVaultDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateVaultResponse>{},
        body: await response.json(),
        bodyKey: "vault",
        bodyModel: model.Vault,
        type: "model.Vault",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }
}
